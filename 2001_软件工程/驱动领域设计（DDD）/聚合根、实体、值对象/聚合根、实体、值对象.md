## 聚合根、实体、值对象

[toc]

#### 前言

在领域驱动设计（Domain-Driven Design，简称DDD）中，实体（Entity）、值对象（Value Object）和聚合根（Aggregate Root）是构成业务模型的核心概念，它们帮助开发者构建出与业务领域紧密相关的模型。下面将分别解释这些概念，并给出定义和示例。

---

#### 实体（Entity）

##### 定义

> 实体是拥有唯一标识和连续存在的对象。

实体是具有唯一标识符（ID）的对象。即使两个实体的属性完全相同（无法通过几个属性的组合来确定唯一对象），只要它们的ID不同，它们也被视为不同的实体。实体的生命周期和行为是领域设计中的重要方面。

##### 举例

在这个例子中，`User` 是一个实体，每个 `User` 都有一个唯一的 `UserId`。即不管姓名、邮箱以及电话等信息如何变，只要通过 Id （比如身份证号）就可以确定一个人（数据库表中的一条记录）。

~~~java
public class User {
    private Long id;
    private String name;
    private String email;
    private String phone;
    private String idCard;
    
    // Constructor、Getters、setters
}
~~~

---

#### 值对象（Value Object）

##### 定义

> 值对象是没有唯一标识，只通过它的属性值来定义的对象。

值对象是描述事物的属性，但没有唯一标识符的对象。值对象应该是不可变的，这意味着一旦创建，其属性就不应该改变。

##### 举例

在这个例子中，`Money` 是一个值对象，它通过货币类型和金额来定义。即无法通过一个字段就确定是什么币种以及金额，必须通过币种和金额在一起才能判断到底有多少钱。

常见的还有地址，通过国家、省份、城市等来确定某一个具体地区，无法通过一个唯一标识就确定是哪个地方。

~~~java
public class Money {
    private Currency currency;
    private BigDecimal amount;

    // Constructor、Getters、setters
}
~~~

~~~java
public class Address {
    private final String street;
    private final String city;
    private final String state;
    private final String zipCode;

		// Constructor、Getters、setters
}
~~~

---

#### 聚合根（Aggregate Root）

##### 定义

> 聚合根是一组相关对象的集合，作为数据修改和事务性操作的边界。

聚合根是一组实体和值对象的集合，这些对象一起作为一致性和交易性的边界。**聚合根负责维护聚合的一致性，并且是外部对象与聚合内部对象交互的唯一入口（Domain层）**。

##### 举例

在这个例子中，`Order` 是一个聚合根，它包含了用户（User）、订单项（`OrderItem`）和收货地址（`Address`），并且维护了订单的总金额（`total`）。其中，User 和 OrderItem 是实体，Money 和 Address 是值对象。

~~~java
public class Order {
    private Long id;
 	  private User user;
    private List<OrderItem> items;
    private Address shippingAddress;
    private Money total;

    // 聚合根中是可以定义相关行为的，即充血模型
    public void addItem(OrderItem item) {
        items.add(item);
        recalculateTotal();
    }

    private void recalculateTotal() {
        total = items.stream()
                     .map(OrderItem::getTotalPrice)
                     .reduce(Money.ZERO, Money::add);
    }

    // Constructor、Getters、setters
}
~~~

---

#### 延伸

##### 实体和值对象的区别

上面有提到，实体能够通过唯一标识来确定一个对象（一条数据库记录），不管是用户还是订单，都能通过一个字段来确定是哪个人、哪笔订单；而值对象没有唯一标识，是通过全部字段来确定一个对象（一条记录）的，像地址、金额，必须同时指定币种和数值才能确定有多少钱。

关于数据库表中的唯一键的理解：

唯一键（几个字段）可以确定唯一一条记录，此时可以考虑其是否可以作为一个值对象；而不能说通过唯一键能确定一个实体对象，因为唯一键相同，但是主键不同，所以就不是同一个对象。

##### 为什么在聚合根中为什么是引用实体和值对象

在领域驱动设计（DDD）中，聚合根（Aggregate Root）引用实体（Entity）和值对象（Value Object）而不是重新定义它们的属性，原因包括但不限于以下几点：

1. **封装性**：每个实体和值对象都应该对其内部状态负责。通过引用而不是复制属性，聚合根尊重了对象的封装性，避免在多个地方重复相同的数据和逻辑。

2. **单一职责原则**：聚合根的职责是维护事务的一致性和完整性，而不是管理实体或值对象的内部实现细节。每个实体和值对象应该负责管理自己的状态和行为。

3. **减少重复**：避免在聚合根中重新定义实体和值对象的属性可以减少代码重复，使得模型更加清晰和易于维护。

4. **灵活性**：实体和值对象可以在多个聚合中使用，而不必依赖于聚合根的具体实现。这样可以提高模型的灵活性和可重用性。

5. **引用透明性**：通过引用实体和值对象，聚合根可以利用它们的内在行为和规则，例如值对象的相等性比较或实体的唯一标识。

6. **维护一致性**：如果聚合根中复制了实体和值对象的属性，任何对实体或值对象的更改都需要在聚合根中同步更新，这增加了维护的复杂性。通过引用，聚合根可以确保总是使用最新的实体和值对象状态。

7. **领域模型的表达力**：DDD旨在创建一个丰富的领域模型，通过引用实体和值对象，可以更准确地表达领域概念和它们之间的关系。

8. **避免副作用**：直接在聚合根中修改实体或值对象的属性可能会导致不可预见的副作用，尤其是在并发环境中。通过引用，可以更好地控制对象间的影响。

9. **优化性能**：在某些情况下，复制大量数据可能会导致性能问题。通过引用，可以减少内存的使用和提高性能。

##### 为什么在聚合根中不是将实体和值对象的属性在聚合根中再定义一遍

在聚合根中引用实体和值对象而不是重新定义它们的属性，是遵循领域驱动设计（DDD）原则的一种做法。这种做法的优点已经在之前的回答中提及。下面我将详细说明如果不这么做，即在聚合根中重新定义实体和值对象的属性，可能会带来的一些缺点：

1. **数据不一致性**：如果在聚合根中复制了实体和值对象的属性，任何对实体或值对象的内部状态的更改都需要在聚合根中同步更新，否则可能导致数据不一致。

2. **代码重复**：重新定义属性会使得相同的数据在系统中多处出现，增加了代码的重复性，这违背了DRY（Don't Repeat Yourself）原则。

3. **维护难度增加**：随着系统的发展，维护多个相同数据的地方将变得非常困难，任何对数据结构的更改都需要在多个地方同步，增加了出错的风险。

4. **违反封装性**：每个类应该对其内部数据负责，聚合根重新定义实体和值对象的属性，破坏了封装性，使得聚合根与实体和值对象的内部实现耦合。

5. **降低灵活性和可重用性**：实体和值对象可能在多个聚合根中使用，如果在聚合根中重新定义了它们的属性，那么这些实体和值对象的可重用性将大大降低。

6. **增加存储和传输成本**：复制属性意味着在存储和传输数据时，相同的数据可能需要多次存储和传输，这增加了存储成本和网络传输成本。

7. **违反单一职责原则**：聚合根承担了过多的职责，不仅要管理自己的逻辑，还要管理实体和值对象的状态，这违背了单一职责原则。

8. **并发问题**：在多线程环境中，如果聚合根直接操作实体和值对象的属性，可能会导致并发访问的问题。

9. **难以扩展**：随着业务逻辑的发展，聚合根内部复制的实体和值对象的属性可能需要扩展，这将导致在聚合根中进行大量的修改，使得系统难以扩展。

10. **测试复杂性**：当聚合根直接包含实体和值对象的属性时，对聚合根的单元测试可能需要构建完整的实体和值对象实例，增加了测试的复杂性。

11. **违反业务规则**：实体和值对象可能包含特定的业务规则，如值对象的不可变性和实体的生命周期管理，聚合根重新定义这些属性可能会使得这些规则难以实施。

12. **性能问题**：对于大型对象，复制属性可能会导致内存使用增加，影响系统性能。

通过引用实体和值对象，而不是复制它们的属性，可以避免上述缺点，同时也能够更好地体现DDD的原则，如模型的丰富性、封装性、单一职责原则等，从而创建出更加清晰、灵活和可维护的系统。

---

