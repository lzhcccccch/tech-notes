# 插入意向锁（Insert Intention Lock）

[toc]

## 简介

插入意向锁是 InnoDB 存储引擎在处理行级锁定时使用的一种特殊类型的锁（特殊的间隙锁），主要用于管理间隙锁（Gap Lock）和行锁（Record Lock）之间的兼容性。它是一种优化机制，使得多个事务能够同时插入同一个间隙（Gap）中的不同位置，而不会彼此阻塞。

---

## 工作原理

- **间隙锁**：间隙锁是一种锁定记录之间的间隙，而不是锁定实际的记录。它用于防止其他事务在间隙中插入新记录，从而保证可重复读（Repeatable Read）隔离级别下的一致性。
- **意向锁**：意向锁是一种表明事务打算在某个资源上加锁的锁。在 InnoDB 中，存在两种类型的意向锁：插入意向锁和意向共享/排他锁（分别对应于共享和排他锁的意向版本）。

**插入意向锁是一种特殊的间隙锁**，它表示一个事务打算在某个特定的间隙中插入一条或多条记录。当多个事务都想在同一个间隙中插入记录时，它们之间不会因为间隙锁而互相阻塞，因为插入意向锁之间是兼容的。这样，只要这些事务插入的记录不冲突（即不尝试插入相同位置的记录），它们就可以并发进行。

---

## 特点

- **互相兼容**：不同事务的插入意向锁之间是兼容的，允许多个事务并发地向同一个间隙插入数据。
- **与其他类型锁的关系**：当一个事务尝试在某个间隙中插入数据时，如果该间隙已经被另一个事务以排他锁（如记录锁或其他间隙锁）锁定，则该事务必须等待排他锁释放。插入意向锁主要是为了与间隙锁和记录锁协同工作，而不是替代它们。
- **优化并发插入**：插入意向锁的主要目的是优化并发插入操作，减少因为间隙锁而导致的不必要的阻塞和等待。

---

## 加锁流程

插入意向锁（Insert Intention Lock）是 MySQL InnoDB 存储引擎中的一种锁机制，用于在插入新记录时表示对某个间隙的插入意图，以避免多个事务在插入操作时相互阻塞。下面是插入意向锁的加锁流程，结合具体步骤进行详细说明。

假设有一个表 `example`，包含以下数据：

```SQL
CREATE TABLE example (
    id INT PRIMARY KEY,
    value VARCHAR(50)
);
INSERT INTO example (id, value) VALUES (4, 'A'), (7, 'B'), (10, 'C');
```

### 加锁流程示例

假设我们有两个事务分别试图在 `id` 为 `5` 和 `6` 的位置插入记录。

#### 事务A：插入 `id = 5`

1. **事务A 开始**：

   ```sql
   START TRANSACTION;
   INSERT INTO example (id, value) VALUES (5, 'D');
   ```

2. **查找插入位置**：

   - InnoDB 引擎会查找适当的插入位置。对于 `id = 5`，找到的插入位置在现有记录 `id = 4` 和 `id = 7` 之间的间隙 `(4, 7)`。

3. **申请插入意向锁**：

   - InnoDB 在间隙 `(4, 7)` 上申请插入意向锁，以表示在该间隙中插入 `id = 5` 的意图。

4. **检查锁冲突**：

   - 检查该间隙是否已经有其他事务持有锁。如果没有，则继续下一步。
   - 插入意向锁与其他插入意向锁是兼容的，可以允许多个插入意向锁存在于同一间隙中。

5. **执行插入操作**：

   - 插入意向锁成功后，插入 `id = 5` 的记录。

6. **提交事务A**：

   ```sql
   COMMIT;
   ```

#### 事务B：插入 `id = 6`

1. **事务B 开始**：

   ```sql
   START TRANSACTION;
   INSERT INTO example (id, value) VALUES (6, 'E');
   ```

2. **查找插入位置**：

   - InnoDB 引擎会查找适当的插入位置。对于 `id = 6`，找到的插入位置同样在现有记录 `id = 4` 和 `id = 7` 之间的间隙 `(4, 7)`。

3. **申请插入意向锁**：

   - InnoDB 在间隙 `(4, 7)` 上申请插入意向锁，以表示在该间隙中插入 `id = 6` 的意图。

4. **检查锁冲突**：

   - 检查该间隙是否已经有其他事务持有锁。事务A 已经在该间隙申请了插入意向锁，但由于插入意向锁与插入意向锁是兼容的，事务B 的插入意向锁不会与事务A 的插入意向锁冲突。

5. **执行插入操作**：

   - 插入意向锁成功后，插入 `id = 6` 的记录。

6. **提交事务B**：

   ```sql
   COMMIT;
   ```

#### 事务C：插入 `id = 8`

1. **事务C 开始**：

   ```sql
   START TRANSACTION;
   INSERT INTO example (id, value) VALUES (8, 'F');
   ```

2. **查找插入位置**：

   - InnoDB 引擎会查找适当的插入位置。对于 `id = 8`，找到的插入位置同样在现有记录 `id = 7` 和 `id = 10` 之间的间隙 `(7, 10)`。

3. **申请插入意向锁**：

   - InnoDB 在间隙 `(7, 10)` 上申请插入意向锁，以表示在该间隙中插入 `id = 8` 的意图。

4. **检查锁冲突**：

   - 检查该间隙是否已经有其他事务持有锁。如果没有，则继续下一步。

5. **执行插入操作**：

   - 插入意向锁成功后，插入 `id = 8` 的记录。

6. **提交事务B**：

   ```sql
   COMMIT;
   ```

#### 事务D：插入 `id = 5`

1. **事务D 开始**：

   ```sql
   START TRANSACTION;
   INSERT INTO example (id, value) VALUES (5, 'D');
   ```

2. **查找插入位置**：

   - InnoDB 引擎会查找适当的插入位置。对于 `id = 5`，找到的插入位置在现有记录 `id = 4` 和 `id = 7` 之间的间隙 `(4, 7)`。

3. **申请插入意向锁**：

   - InnoDB 在间隙 `(4, 7)` 上申请插入意向锁，以表示在该间隙中插入 `id = 5` 的意图。

4. **检查锁冲突**：

   - 检查该间隙是否已经有其他事务持有锁。事务A 已经在该间隙申请了插入意向锁，且事务 A 在 `id = 5` 上添加了排他锁，所以事务 D 阻塞，直到事务 A 提交或回滚，才能继续下一步。

5. **执行插入操作**：

   - 插入意向锁成功后，插入 `id = 5` 的记录。

6. **提交事务A**：

   ```sql
   COMMIT;
   ```

---

## 锁的兼容性

插入意向锁的设计是为了允许多个事务在同一个间隙中插入不同的位置，因此不会相互阻塞。以下是插入意向锁的兼容性：

- **插入意向锁与插入意向锁**：兼容，不会相互阻塞。
- **插入意向锁与间隙锁**：兼容，除非间隙锁覆盖了整个间隙。
- **插入意向锁与临键锁**：兼容，只要插入位置不在临键锁的覆盖范围内。

---

## 总结

插入意向锁允许多个事务在同一个间隙中插入不同位置的记录，从而提高并发性能。加锁流程包括查找插入位置、申请插入意向锁、检查锁冲突以及执行插入操作。在同一个间隙中的插入意向锁是兼容的，这意味着多个事务可以在同一个间隙中插入记录而不会相互阻塞。