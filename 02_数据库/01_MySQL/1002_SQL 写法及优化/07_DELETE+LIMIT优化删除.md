# DELETE+LIMIT优化删除

[toc]

## 简介

在使用 MySQL 执行 `DELETE` 语句时，添加 `LIMIT` 子句可以帮助控制删除操作的范围，避免意外删除过多数据或导致性能问题。下面分析一下添加 `LIMIT` 的原因和作用。

---

## MySQL 执行 DELETE 的原理

### 锁机制

- InnoDB 是 MySQL 中最常用的存储引擎，采用行级锁。
- 在执行 `DELETE` 语句时，MySQL 会为被删除的每一行数据加锁，以防止其他事务对这些数据的并发操作。
- 如果删除的行数过多，会锁住大量数据，甚至会导致锁等待和死锁。

### 事务机制

- MySQL 的事务（Redo Log）和回滚日志（Undo Log）负责记录实务操作。
- 当删除一条数据时，InnoDB 并不会立刻删除数据文件中的记录，而是将变更写入 UndoLog，以支持回滚。
- 如果一次性删除太多数据，Undo Log 会变得非常大，甚至可能占用大量的磁盘空间和内存，增加事务回滚的代价。

### 磁盘 I/O 和内存

- 删除操作会将被删除的页面添加载到 InnoDB 缓冲池（Buffer Pool）中，操作完成后这些页面需要被标记为”脏页“，并在适当的时候将其刷入磁盘。
- `DELETE` 删除数据时，并不是真的把数据删除，只是给删除的数据打了个标记（标记为已删除），因此表文件在磁盘上所占空间不会变小，存储空间不会被释放，只是把删除的数据行设置为不可见。虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用这部分空间（即新的数据覆盖在旧数据的磁盘位置上），所以会导致磁盘空间碎片化。
- 如果一次性删除大量数据，MySQL 的缓存池可能会被填满，进而影响其他查询的性能。

### 二进制文件（Binlog）

- 在开启主从同步的情况下，MySQL 会将删除操作写入 Binlog，并通过主从复制将删除操作同步到从库。
- 一次性删除太多数据会导致 Binlog 变得非常大，导致从库的同步延迟，甚至可能触发主从延迟。

---

## DELETE 操作的开销

### 全表扫描的代价

如果在没有限制的情况下执行 `DELETE` 操作，尤其是删除大量数据时，MySQL 需要扫描满足条件的**所有行，然后逐一删除**。这会导致较大的 I/O开销。

### 日志文件的压力

MySQL 在执行 `DELETE` 时，会记录每一行的删除操作到事务日志中（用于回滚和恢复数据）。如果一次性删除大量数据数据，日志文件会迅速膨胀，增加磁盘压力，甚至导致性能下降。

在开启主从同步的情况下，MySQL 还会将删除操作写入 Binlog，一次性删除大量数据，会导致 Binlog 文件过大， 从而导致从库的同步延迟。

### 锁的开销

`DELETE` 操作会对受影响的行加锁，如果删除的行数过多，锁的范围可能会扩大，影响其他事务的并发性能。

---

## LIMIT 的作用

### 核心理念

通过限制删除的行数，从而降低锁的竞争，减少日志等开销。

### 控制删除的行数，降低锁的竞争

大批量删除会持有大量的行级锁，可能会引发死锁。`LIMIT` 限制每次删除的行数，MySQL 只锁定这些行，从而减少了锁的范围，降低了对其他事务的影响，从而提高了并发性能。

**示例**

~~~sql
DELETE FROM orders 
WHERE status = 'cancelled' 
LIMIT 1000;
~~~

上面 SQL 中，如果不加 `LIMIT`，整个 `WHERE` 语句选中的所有行都会被锁定，而加了 `LIMIT 1000`，只会锁住 1000 行。

### 减少事务日志和回滚代价

MySQL 使用 Undo Log 来支持事务回滚，如果删除大量数据会导致日志文件过大，从而导致磁盘空间不足和回滚时间过长。`DELETE ... LIMIT` 将大事务拆解成多个小事务，减小日志文件体积，降低回滚代价，减小磁盘 I/O 的压力。

### 控制内存消耗，减小 InnoDB 缓存压力

MySQL 通过缓存池（Buffer Pool）缓存数据页，批量删除会加载大量数据页到内存，导致缓存池中的脏页增多，MySQL 需要不断的刷脏页到磁盘，从而导致性能抖动。限制删除数据的数量，减少对缓存池的污染，避免性能抖动。

### 防止主从同步延迟

MySQL 在主从复制中使用 Binlog，一次性删除大量数据，导致 Binlog 过大，导致主从同步延迟。限制 Binlog 大小，避免主从同步延迟。

---

## DELETE + LIMIT 的典型使用场景

### 大量数据清理

当表中有大量历史数据需要清理时，可以分批删除，从而避免一次性删除过多数据导致的性能问题。

### 在线系统的性能保护

在高并发的在线系统中，直接执行大规模的删除操作可能会导致锁争用，影响其他用户的正常操作。通过 `LIMIT` 分批删除，可以降低对系统的冲击。

### 避免超时或崩溃

如果一次性删除的数据量过大，可能会导致 SQL 超时或数据库崩溃。分批删除可以显著降低这种风险。

---

## 注意事项

### 索引优化

在使用 `DELETE` 时，确保条件字段上有合适的索引，以避免全表扫描。

### 组合 ORDER BY

有时需要结合 `ORDER BY` 来确保删除的顺序。例如：

```sql
DELETE FROM table_name WHERE condition ORDER BY id ASC LIMIT 1000;
```

这样可以按照主键或其他字段的顺序分批删除，避免删除顺序不确定的问题。

### 外键约束

如果表中有外键约束，分批删除可能触发级联删除，需要特别注意关联表的影响。

---

## 总结

在 MySQL 中，`DELETE` 结合 `LIMIT` 是一种非常实用的性能优化手段，尤其是在需要删除大量数据的场景下。通过限制每次删除的行数，可以有效控制系统资源的使用，避免对数据库性能的过大影响，同时保证操作的安全性和稳定性。这种方式也为分批处理提供了灵活性，是数据库运维和开发中的常见技巧。