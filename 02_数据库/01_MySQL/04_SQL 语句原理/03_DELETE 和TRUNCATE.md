## DELETE 和 TRUNCATE

[toc]

#### 简介

在 MySQL 中，`DELETE` 和 `TRUNCATE` 都用于删除表中的数据，但它们有显著的区别。以下是对这两个命令的详细介绍及对比。

---

#### DELETE 语句

`DELETE` 是一个 DML（数据操作语言）语句，用于按条件删除表中的一行或多行数据。

**语法**：

```sql
DELETE FROM table_name WHERE condition;
```

- **WHERE 子句**：你可以通过 `WHERE` 子句指定删除的条件。如果不使用 `WHERE` 子句，则删除表中的所有行，但表的结构和索引会被保留。
- **逐行删除**：`DELETE` 语句是逐行删除的（无论是否带 `WHERE` 条件，都是逐行删除），这意味着每删除一行都会记录到 `binlog` 中，并触发与该表关联的任何 `DELETE` 触发器。
- **事务支持**：`DELETE` 支持事务操作，删除操作可以回滚。因此，如果表在事务中，使用 `ROLLBACK` 可以恢复被删除的数据。
- **影响行数**：`DELETE` 操作会返回受影响的行数，便于知道有多少行被删除。
- **影响外键**：`DELETE` 操作会遵守外键约束，如果有外键关系，需要注意子表的删除规则（如 `ON DELETE CASCADE`）。
- **触发器**：DELETE 会触发表上定义的 DELETE 触发器。
- **释放磁盘空间**：`DELETE FROM TABLE` 删除表的全部数据，对于 MyISAM 会立刻释放磁盘空间，InnoDB 不会释放磁盘空间。不过在执行 `DELETE` 操作之后，再执行 `OPTIMIZE TABLE TALBE_NAME` 会立刻释放磁盘空间，不管是 InnoDB 还是 MyISAM。
- **磁盘空间碎片化**：`DELETE` 删除数据时，并不是真的把数据删除，只是给删除的数据打了个标记（标记为已删除），因此表文件在磁盘上所占空间不会变小，存储空间不会被释放，只是把删除的数据行设置为不可见。虽然未释放磁盘空间，但是下次插入数据的时候，仍然可以重用这部分空间（即新的数据覆盖在旧数据的磁盘位置上），所以会导致磁盘空间碎片化（标记删除的数据磁盘空间大小无法存放新插入的数据）。

**使用场景**：

- 当需要有条件删除某些行时，`DELETE` 是最佳选择。例如，你可能只想删除过期的数据或特定用户的数据。
- 如果你想在删除数据的过程中保留事务的控制能力，以确保在出错时能够回滚，DELETE 也是合适的。

---

#### TRUNCATE 语句

`TRUNCATE` 是一个 DDL（数据定义语言）语句，用于快速删除表中的所有行。它实际上是重新创建表的方式来清空表，因此不会逐行删除数据。

**语法**：

```sql
TRUNCATE TABLE table_name;
```

- **删除所有数据**：`TRUNCATE` 不允许使用 `WHERE` 子句。它会直接删除表中的所有数据，并且比 `DELETE` 更高效。
- **重置自增列**：如果表中有 `AUTO_INCREMENT` 列，`TRUNCATE` 会将该列的计数器重置为初始值。
- **不逐行删除**：与 `DELETE` 不同，`TRUNCATE` 不逐行删除数据，而是通过直接重置表来释放表的空间。它不会逐行写入到 `binlog`，也不会触发任何 `DELETE` 触发器。
- **不支持事务**：`TRUNCATE` 不支持回滚操作。如果在事务中使用 `TRUNCATE`，操作立即生效且无法回滚。
- **外键约束**：在有外键约束的表中，如果存在外键依赖关系，`TRUNCATE` 通常无法直接使用，需要先删除或禁用外键。
- **自动提交**：TRUNCATE 是 DDL（数据定义语言）操作，执行后会立即提交，因此不支持回滚。这意味着它不能像 DELETE 那样在事务中被撤销。
- **不触发触发器**：TRUNCATE 不会触发 DELETE 触发器。
- **释放磁盘空间**：执行完毕就释放磁盘空间。

**使用场景**：

- 当需要快速清空表中的所有数据且不需要保留细粒度的日志或触发器支持时，`TRUNCATE` 是更高效的选择。

---

#### DELETE 与 TRUNCATE 的对比

| 特性             | DELETE                                           | TRUNCATE                           |
| ---------------- | ------------------------------------------------ | ---------------------------------- |
| **类型**         | DML (数据操作语言)                               | DDL (数据定义语言)                 |
| **作用对象**     | 按条件删除特定行或删除所有行                     | 删除表中的所有行                   |
| **WHERE 支持**   | 可以使用 `WHERE` 子句按条件删除                  | 不支持，删除所有数据               |
| **自增列重置**   | 不重置自增列                                     | 会重置自增列                       |
| **触发器**       | 会触发 `DELETE` 触发器                           | 不会触发任何触发器                 |
| **事务支持**     | 支持，能够回滚                                   | 不支持，删除后无法回滚             |
| **性能**         | 相对较慢，逐行删除                               | 高效，直接释放表空间               |
| **外键约束**     | 支持外键约束                                     | 不支持，如果有外键，需要先禁用外键 |
| **锁机制**       | 行级锁 (InnoDB)                                  | 表级锁                             |
| **日志记录**     | 逐行记录到 binlog                                | 只记录表元数据的变更，不逐行记录   |
| **磁盘空间释放** | MyISAM 会释放，InnoDB 需要执行 optimize 才能释放 | 立即释放                           |

---

#### 性能差异

- **DELETE 的性能**：由于逐行删除，`DELETE` 的性能相对较低，尤其是在没有索引的大表上进行删除操作时。删除每一行都会记录日志，并触发触发器（如果存在），这会进一步增加删除的开销。
- **TRUNCATE 的性能**：`TRUNCATE` 的性能更好，因为它不是逐行删除数据，而是直接重置整个表的元数据。这使得它在删除大表中的所有数据时非常高效。`TRUNCATE` 的性能近似于 `DROP` 表后重建表。

---

#### 总结

- 如果需要保留表的日志、细粒度的控制或者需要事务支持，应该选择 `DELETE`。
- 如果仅是为了快速清空表中的数据，且不需要事务和触发器，`TRUNCATE` 是更高效的选择。

总结来说，`DELETE` 适用于按条件删除数据且需要细粒度的控制，而 `TRUNCATE` 更适用于快速清空表数据的场景。