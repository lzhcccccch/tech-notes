# MySQL 中的索引

[toc]

## 简介

在 MySQL 中，索引是数据库表的一种数据结构，用于提高查询性能。不同类型的索引适用于不同的查询需求和存储引擎。

其中，普通索引、唯一索引、主键索引、复合索引、前缀索引可以统称为 B+ Tree 索引。

在 InnoDB 中，可以将索引分为两类：聚簇索引和非聚簇索引。聚簇索引即主键索引，非聚簇索引即除主键索引之外的任何索引。

---

## 普通索引（Normal Index）

普通索引是最基本的索引类型，用于加速数据的查询。

### 特点

- **允许重复值**：索引列可以有重复值。
- **支持多种查询**：包括等值查询、范围查询、前缀查询和排序操作。
- **数据结构**：通常使用 B+ Tree 结构。
- **索引列范围**：可以在单个列或者多个列（组合索引）上创建普通索引，可以创建多个普通索引。

### 优点

- **提高查询性能**：显著减少查询操作的时间。

- **灵活性**：可以在任意列上创建多个普通索引。

- **支持多种查询**：支持多种查询类型。

### 缺点

- **维护开销**：增加插入、更新和删除操作的成本。
- **占用空间**：需要额外的存储空间。

### 使用方式

如果是 CHAR，VARCHAR 类型， length 可以小于字段的实际长度，如果是BLOB和TEXT类型就必须指定长度。

- 创建表时定义：

  ```sql
  CREATE TABLE employees (
      id INT PRIMARY KEY AUTO_INCREMENT,
      name VARCHAR(100),
      INDEX idx_name (name)
  ) ENGINE=InnoDB;
  ```

- 创建表后添加：

  ```sql
  CREATE INDEX IndexName ON `TableName`(`字段名`);
  # 或者修改表结构
  ALTER TABLE TableName ADD INDEX IndexName(`字段名`);
  ```

- 删除索引

  ~~~sql
  DROP INDEX [indexName] ON mytable;
  ~~~

### 使用场景

- **频繁的查询操作**：如 WHERE 子句、ORDER BY 子句和 JOIN 子句中的列。
- 需要快速查找数据。

---

## 唯一索引（Unique Index）

唯一索引类似于普通索引，但它要求索引列中的所有值（单个列或多个列的组合索引）都是唯一的，除了允许一个 NULL 值。

数据结构是 B+ Tree 结构。

### 特点

- **强制唯一性**：索引列中的每个值必须唯一。
- **NULL 值**：可以包含 NULL 值，但是只允许一个 NULL 值。
- **AUTO_INCREMENT 列**： `AUTO_INCREMENT`列必须定义为主键（`PRIMARY KEY`）或唯一索引（`UNIQUE`）。
- **数据结构**：通常使用 B+ Tree 结构。

### 优点

- **数据唯一性**：确保数据唯一性，防止重复数据。
- **提高查询性能**：提高查询性能，尤其在唯一性查询时。

### 缺点

- **插入性能稍低**：插入性能低，因为插入前需要检查唯一性。

- **维护开销**：增加插入、更新和删除操作的成本。

### 使用方式

- 创建表时定义：

  ```sql
  CREATE TABLE users (
      id INT PRIMARY KEY AUTO_INCREMENT,
      email VARCHAR(100) UNIQUE
  ) ENGINE=InnoDB;
  ```

- 创建表后添加：

  ```sql
  # column_list 是指一个或者多个列（字段）
  CREATE UNIQUE INDEX IndexName ON `TableName`(column_list);
  # 或者修改表结构
  ALTER TABLE TableName ADD UNIQUE (column_list); 
  ```

### 已有数据的表添加唯一索引

在已有数据的表上添加唯一索引要注意：

* 如果添加索引列的值存在两个或两个以上的空值，则不能创建唯一索引，会失败。（一般在创建表时，要对添加唯一索引的列设置 NOT NULL）
* 如果添加索引列的值存在两个或两个以上的 null 值，可以创建索引，会成功，但是后续不能继续再插入 null 值，并且严格意义来说该列并不是唯一的，因为有多个 null 值。

> 空值和 NULL 的概念：
>
> 1.  空值是不占用空间的，MySQL 中 NULL 值是占用空间的
> 2.  空值之间是没有空格的，就是一个空的（'')，而 NULL 值是有长度的

### 使用场景

- 用于需要唯一约束的列，例如电子邮件、身份证号等。
- 确保数据的唯一性。

---

## 主键索引（Primary Key Index）

主键索引是一种特殊的唯一索引，用于唯一标识表中的每一行记录。主键索引不允许有 NULL 值。每个表只能有一个主键索引。

### 特点

- **唯一性和非空约束**：主键列的值必须唯一且不能为空。
- **聚簇索引**：在 InnoDB 中，主键索引是聚集索引，数据按逐渐顺序存储。非主键索引就是非聚簇索引。
- **自动创建**：在 InnoDB 中，如果没有显示的创建主键索引且没有唯一索引，MySQL 会自动创建一个隐式的主键索引。
- **AUTO_INCREMENT 列**： `AUTO_INCREMENT`列必须定义为主键（`PRIMARY KEY`）或唯一索引（`UNIQUE`）。
- **数据结构**：通常使用 B+ Tree 结构。

### 优点

- 唯一标识每行数据，确保数据的唯一性和完整性。
- 提升查询性能，尤其是基于主键的查询。

### 缺点

- 每个表只能有一个主键，限制了灵活性；
- 插入和更新需要维护索引，有一定开销。

### 自动创建

在MySQL中，如果在创建表时没有显示地指定主键索引，MySQL不会自动创建主键索引。但如果表中有一个`UNIQUE`索引且该索引中的所有列都不能为空（`NOT NULL`），MySQL会使用这个`UNIQUE`索引作为表的主键。如果没有这样的`UNIQUE`索引，MySQL会尝试找到一个适合作为主键的列。

具体规则如下：

1. **没有指定主键，也没有`UNIQUE`索引：**
   - MySQL不会自动创建主键索引。
   - 如果表使用的是`InnoDB`存储引擎，MySQL会创建一个隐式的聚簇索引（称为行ID，`row_id`）作为主键，但这个隐式主键对用户是不可见的。
2. **有一个或多个`UNIQUE`索引：**
   - 如果表中存在一个或多个`UNIQUE`索引，且索引列中的所有列都不能为空（`NOT NULL`），MySQL会使用第一个`UNIQUE`索引作为主键索引。
3. **既没有显式主键，也没有适合的`UNIQUE`索引：**
   - 如果表没有显式的主键，也没有适合的`UNIQUE`索引，MySQL在使用`InnoDB`存储引擎时会创建一个隐式的行ID作为聚簇索引。

### MyISAM 引擎中的主键索引

MyISAM 引擎不支持聚簇索引，所以在 MyISAM 引擎中，主键索引并不等于聚簇索引。

MyISAM 按照插入的顺序在磁盘上存储数据：左边为行号(row number)，从 0 开始。因为元组的大小固定，所以MyISAM可以很容易的从表的开始位置找到某一字节的位置。如图：

![image-20240717155223169](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240717155223169.png)

col1 主键索引：

MyISAM 不支持聚簇索引，索引中每一个叶子节点仅仅包含行号(row number)，且叶子节点按照 col1 的顺序存储。

![image-20240717155352745](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240717155352745.png)

col2 非主键索引：

在 MyISAM 中，primary key 和其它索引没有什么区别。Primary key 仅仅只是一个叫做 PRIMARY 的唯一，非空的索引而已，叶子节点按照 col2 的顺序存储。

![image-20240717155416824](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240717155416824.png)

### 使用方式

- 创建表时定义：

  ```sql
  CREATE TABLE products (
      product_id INT PRIMARY KEY,
      name VARCHAR(100)
  ) ENGINE=InnoDB;
  ```

### 使用场景

- 每个表必须有一个唯一标识列，如主键。

---

## 复合索引（Composite Index）

复合索引是在多个字段上创建索引，index(a,b,c)存储时先根据 a 排序，a 一样就根据 b 排序，b 一样根据 c 排序，所以要遵循**最左匹配原则**。

复合索引可以是普通索引，也可以是唯一索引（参考唯一索引和普通索引）。

### 特点

- 遵循最左前缀原则，就是说只有在查询条件中使用了复合索引的第一个字段，索引才会生效。
- 必须由 2 个及以上的列组成。
- **索引覆盖（Covering Index）**：如果查询的所有列都在复合索引中，那么即使查询条件只用到了部分前缀，索引仍然可以覆盖查询，提升性能。
- 数据结构是 B+ Tree 结构。

### 优点

- 提高多列查询的效率。如果查询的所有列都在复合索引中，那么即使查询条件只用到了部分前缀，索引仍然可以覆盖查询，提升性能。

### 缺点

- 维护成本高。
- 顺序很重要，必须按照创建索引时的顺序使用（最左匹配原则）。

### 使用场景

- 适用于需要同时查询多个列的场景。

### 最左匹配原则

最左匹配原则指出，当查询使用复合索引时，只有在查询条件中包含索引的最左前缀列时，索引才能被有效利用。换句话说，查询条件必须从复合索引的最左列开始，才能使用该索引。

#### 索引生效和失效

比如建立了组合索引 `index(a, b, c)`，可以理解为建立了4个索引（实际只有一个），分别为 `index(a)` 、`index(a,b)` 、`index(a,c)` 、`index(a,b,c)` 。其中，查询 `(a, c)` 并不能有效利用组合索引 `index(a, b, c)`，因为它没有遵循最左匹配原则：即在索引中连续地使用列。对于这种情况，只有 `a` 列会通过索引被优化，而 `c` 列将进行全表扫描或其他非索引优化的查询处理。其他的查询情形，即 `(a)`、`(a, b)` 和 `(a, b, c)`，则可以充分利用索引进行数据检索和优化。

#### 示例

~~~sql
# 除了会让索引失效的，比如 or，like ‘%xxx%’等，针对组合索引失效，以 index（a,b,c) 为例
where b="xxx";  where b="xxx" and c="yyy";  // 索引失效，因为没有该条件的等价索引
# 对某个列进行范围查询，则其右边的列不会使用索引
where a="xxx" and b like "yy%" and c="zzz"; // 只会对 a 和 b 列进行索引，相当于使用 index(a,b)
# 不能跳过最左列
where a>"xxx" and b="yyy" and c="zzz"; // 不会使用索引
~~~

---

## 全文索引（Full-Text Index）

全文索引用于快速地进行全文搜索，主要用于搜索文本内容中的关键词，适用于大段文本数据的全文检索。

### 特点

- **文本搜索**：适用于大块文本数据的关键词搜索。
- **数据结构**：基于倒排索引结构，记录每个词出现的位置。
- **列限制**：只能在`CHAR`、`VARCHAR`和`TEXT`列上创建。
- **查询模式**：使用 MATCH() AGAINST() 语法进行全文搜索，不支持 LIKE 查询。
- **引擎支持**：只在 MyISAM 和 InnoDB 引擎中支持，其中 InnoDB 引擎是在 MySQL5.6 之后才支持，在此之前只支持 MyISAM 引擎。

### 优点

- **高效的全文搜索**：支持复杂的文本搜索，如关键词匹配、短语搜索，适用于大段文本数据。
- **支持复杂查询**：如包含多个关键词的查询，支持自然语言模式和布尔模式。
- **全文搜索**：支持复杂的文本搜索，如关键词匹配、短语搜索。

### 缺点

- **索引体积大**：占用大量存储空间。

- **更新成本高**：插入、更新和删除操作需要更新索引。

- **查询范围**：不适用于小文本，不适用于精确查询。

### 使用方式

- 创建表时定义：

  ```sql
  CREATE TABLE articles (
      id INT PRIMARY KEY AUTO_INCREMENT,
      title VARCHAR(200),
      content TEXT,
      FULLTEXT (title, content)  -- 全文索引
  ) ENGINE=InnoDB;
  ```

- 创建表后添加：

  ```sql
  CREATE FULLTEXT INDEX idx_content ON articles (content);
  ```

- 查询：

  ~~~SQL
  # 使用全文索引，把 column1 和 column2 字段里有 xxx、sss、和 ddd 的数据记录全部查询出来。
  SELECT * FROM TableName WHERE MATCH(column1, column2) AGAINST('xxx', 'sss', 'ddd');
  ~~~

### 使用场景

- 适用于博客、文章、评论等需要全文搜索的场景。

---

## 空间索引（Spatial Index）

空间索引用于存储和查询地理空间数据，适用于存储空间对象的几何数据类型。只有 MyISAM 存储引擎支持真正的空间索引，使用 R-Tree 算法。

### 特点

- **多维数据**：支持多维数据的存储和查询。
- **支持空间数据类型**：如 GEOMETRY、POINT、LINESTRING、POLYGON 等。
- **数据结构**：通常使用 R-Tree 结构。

### 优点

- 提供高效的空间数据查询，如包含、相交等空间操作。
- 支持复杂的空间关系查询。

### 缺点

- 复杂性高，构建和维护索引的成本较高。
- MyISAM 支持完全的空间索引，InnoDB 支持有限。

### 使用方式

- 创建表时定义：

  ```sql
  CREATE TABLE locations (
      id INT PRIMARY KEY AUTO_INCREMENT,
      geom GEOMETRY NOT NULL,
      SPATIAL INDEX (geom)
  ) ENGINE=MyISAM;
  ```

### 使用场景

- 地理信息系统（GIS）、地图应用、位置服务等需要处理空间数据的场景。

---

## 哈希索引（Hash Index）

哈希索引用于快速等值查询，通过哈希表实现。

### 特点

- **查询类型**：支持等值查询，且速度非常快；不支持范围查询和排序操作。
- **非排序性**：索引存储的数据无序，所以不支持排序。
- **冲突处理**：哈希冲突可能影响性能。
- **引擎支持**：只有 Memory 存储引擎默认支持哈希索引。InnoDB不支持显示地创建Hash索引，只支持自适应哈希索引。
- **数据结构**：数据结构是哈希结构。

### 优点

- 等值查询性速度快，查找操作非常高效。

### 缺点

- 只适用于等值查询，不支持范围查询。
- 因为存储无序，所以不支持排序。
- 哈希冲突处理复杂，冲突会影响性能。

### 使用方式

- 创建表时定义：

  ```sql
  CREATE TABLE memory_example (
      id INT PRIMARY KEY,
      name VARCHAR(100),
      INDEX idx_name (name) USING HASH
  ) ENGINE=MEMORY;
  ```

### 使用场景

- 适用于快速等值查询的场景，如缓存系统。

---

## 自适应哈希索引

自适应哈希索引是 InnoDB 存储引擎的一项优化技术，它通过动态地将 B-Tree 索引的一部分转换为哈希索引，来提高频繁查询的性能。其基本思想是在 B-Tree 索引的基础上，通过检测数据访问模式，自动生成哈希索引，以加快数据访问速度。

### 工作机制

1. 监测访问模式：

   InnoDB 会监测数据页的访问模式，特别是查找操作的频率和类型。当检测到某些数据页被频繁访问时，系统会考虑将这些页转换为哈希索引。

2. 创建哈希索引：

   当某个页的访问频率达到一定阈值时，InnoDB 会在内存中为该页创建一个哈希索引。这个哈希索引会记录页中数据的键值和对应的物理位置。

3. 使用哈希索引：

   一旦哈希索引被创建，后续对这些高频数据的查找操作将通过哈希表进行，查找速度会显著提升，因为哈希查找的时间复杂度是 O(1)，而 B-Tree 查找的时间复杂度是 O(log N)。

4. 动态调整：

   自适应哈希索引是动态调整的，如果某些数据页的访问频率下降，InnoDB 会自动移除相应的哈希索引，以节省内存资源。

### 优点

- **提高查询性能**：对于高频访问的数据页，哈希索引可以显著提高查找速度，减少查询响应时间。

- **自动调整**：InnoDB 会根据数据访问模式自动创建和删除哈希索引，无需用户手动干预。
- **节省资源**：由于哈希索引是动态创建和删除的，系统只会为真正需要优化的数据页创建哈希索引，从而节省内存资源。

### 缺点

- **内存消耗**：哈希索引会占用一定的内存，因此在内存有限的情况下，需要权衡其带来的性能提升和内存消耗。

- **场景限制**：自适应哈希索引特别适用于高频读操作的场景，但在高并发写操作场景下，需要谨慎使用，因为哈希索引的维护也会带来一定的开销。在随机或低频访问模式下效果有限。

- **控制权**：因为是自动管理的，管理员无法完全控制自适应哈希索引的行为。在某些情况下，可能需要禁用或调整其行为。

### 使用方式

- **启用和禁用**：可以通过 `innodb_adaptive_hash_index` 系统变量来启用或禁用自适应哈希索引。

  ~~~sql
  SET GLOBAL innodb_adaptive_hash_index = ON;  -- 开启自适应哈希索引
  SET GLOBAL innodb_adaptive_hash_index = OFF; -- 关闭自适应哈希索引
  ~~~

- **监控和调优**：可以通过 `SHOW ENGINE INNODB STATUS` 命令来查看自适应哈希索引的状态和统计信息。

  ```sql
  SHOW ENGINE INNODB STATUS;
  ```

  在输出的结果中，可以找到关于自适应哈希索引的统计信息，如命中率和内存使用情况。

### 优化建议

1. **适量内存分配**：确保系统有足够的内存来支持自适应哈希索引的使用。定期监控内存使用情况，避免内存不足。

2. **观察命中率**：通过 `SHOW ENGINE INNODB STATUS` 命令，观察自适应哈希索引的命中率。如果命中率低，可以考虑禁用自适应哈希索引。

3. **负载测试**：在生产环境中启用自适应哈希索引之前，先在测试环境中进行负载测试，确保在实际工作负载下能带来性能提升。

---

## 前缀索引（Prefix Index）

前缀索引不是一个单独的索引类型，而是一种可以在创建索引时指定的技术，通过只索引字段值的前几个字符来减少索引大小。例如，如果你有一个很长的文本列，但你知道前 10 个字符通常足够区分大多数行，你可以只索引前 10 个字符。

### 特点

- **节省空间**：索引的存储空间更少，因为只索引了列值的前缀部分。
- **提高性能**：在某些情况下，查询性能可以提高，因为索引的数据量较少。
- **列类型**：仅适用于字符串类型（CHAR、VARCHAR、TEXT）
- **数据结构**：数据结构是 B+ Tree 结构。

### 优点

- **节省存储空间**：索引大小较小，适用于长字符串列。
- **提高索引创建速度**：索引创建和维护速度较快。
- **提高查询性能**：在某些查询场景下，性能提升明显，特别是当索引列的前 N 个字符足以区分大多数记录时。

### 缺点

- **索引选择性下降**：前缀部分可能不足以区分所有行，导致索引选择性降低。
- **不能完全支持 ORDER BY 和 GROUP BY**：前缀索引不能用于完全排序或分组操作，只能用于索引前缀的排序和分组。
- **只能用于某些查询类型**：不适用于需要完全匹配整个字符串列值的查询。

### 使用方式

创建前缀索引时，需要指定要索引的前缀长度。通常，根据列值的分布情况，选择一个适当的前缀长度，以在节省空间和保证查询性能之间取得平衡。

1. 创建表时定义前缀索引

```sql
CREATE TABLE example (
    id INT PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255),
    INDEX idx_name_prefix (name(10)),   -- 前 10 个字符的前缀索引
    INDEX idx_email_prefix (email(15))  -- 前 15 个字符的前缀索引
);
```

2. 在表创建后添加前缀索引

```sql
CREATE INDEX idx_name_prefix ON employees (name(10));  -- 只索引 name 列的前 10 个字符
```

3. 查询示例

~~~sql
SELECT * FROM user WHERE name LIKE 'John%';  -- 利用 name 列的前缀索引
SELECT * FROM user WHERE email LIKE 'john.doe%';  -- 利用 email 列的前缀索引
~~~

### 使用场景

- **长字符串列**：适用于那些字段内容较大且前几个字符足以区分大多数记录的列，例如 URL、电子邮件地址、大文本字段等。
- **前缀部分足够区分的情况**：前缀部分能够很好地区分大多数行数据。
- **节省存储空间的需求**：需要减少索引存储空间。

### 前缀索引与全索引的对比

| 特点               | 前缀索引                                  | 全索引                     |
| ------------------ | ----------------------------------------- | -------------------------- |
| 存储空间           | 较小                                      | 较大                       |
| 索引创建和维护速度 | 较快                                      | 较慢                       |
| 查询性能           | 在特定情况下较高                          | 在全匹配查询中较高         |
| 索引选择性         | 可能较低，具体取决于前缀长度              | 较高，能够区分更多行       |
| 适用场景           | 长字符串列，前缀部分足够区分              | 需要完全匹配整个列值的查询 |
| 支持的列类型       | 仅适用于字符串类型（CHAR、VARCHAR、TEXT） | 适用于所有类型             |

---

## 索引对比

| 索引类型 | 定义                   | 数据结构 | 特点                                               | 优点                             | 缺点                                                       | 使用方式                           | 适用场景                                          |
| -------- | ---------------------- | -------- | -------------------------------------------------- | -------------------------------- | ---------------------------------------------------------- | ---------------------------------- | ------------------------------------------------- |
| 普通索引 | 基础索引，无唯一性约束 | B+ Tree  | 允许重复值，支持多种查询操作                       | 显著提高查询性能，灵活           | 插入、更新、删除操作有开销，占用快哦紧固件                 | CREATE INDEX 或 ALTER TABLE        | 频繁查询的列，如 WHERE 子句                       |
| 唯一索引 | 强制唯一性约束         | B+ Tree  | 确保列值唯一，允许一个 NULL 值                     | 确保数据唯一性，提高查询性能     | 插入和更新时性能稍有影响                                   | CREATE UNIQUE INDEX 或 ALTER TABLE | 需要唯一约束的列，如电子邮件、身份证号            |
| 主键索引 | 特殊的唯一索引         | B+ Tree  | 唯一标识每行数据，每表只能有一个；聚簇索引         | 唯一标识每行数据，提高查询性能   | 每个表只能有一个，插入和更新有一定开销                     | 在创建表时定义                     | 必须有一个唯一标识列，如主键                      |
| 全文索引 | 加速文本搜索           | 倒排索引 | 大块文本的关键词搜索                               | 快速高效的全文搜索，支持复杂查询 | 适用于大文本，创建和维护开销大；不支持精确查找和小范围查询 | CREATE TABLE 或 ALTER TABLE        | 博客、文章、评论等需要全文搜索的场景              |
| 空间索引 | 存储和查询地理空间数据 | R-Tree   | 支持多维数据、地理空间数据                         | 高效处理地理空间数据             | 复杂性高，仅适用于 MyISAM 引擎（InnoDB 支持有限）          | CREATE TABLE 或 ALTER TABLE        | 地理信息系统（GIS）、地图应用等处理空间数据的场景 |
| 哈希索引 | 基于哈希表             | 哈希表   | 通过哈希函数定位，提供快速等值查询；不支持范围查询 | 等值查询性能高，简单实现         | 不支持范围查询、无序存储；哈希冲突处理复杂                 | CREATE TABLE                       | 快速等值查询，如缓存系统                          |

---

## 查看删除索引

### 查看

```sql
SHOW INDEX FROM table_name;
```

### 删除

~~~sql
DROP INDEX index_name ON table_name;
# 或者
ALTER TABLE my_table DROP INDEX idx_name;
~~~

---

## 总结

MySQL 提供了多种索引类型，每种索引类型在特定场景下都有独特的优势和劣势。选择合适的索引类型，可以显著提高数据库查询性能和整体效率。在实际应用中，根据具体需求选择合适的索引类型，是优化 MySQL 数据库性能的关键。理解每种索引的特点、优缺点和使用场景，有助于设计出高效的数据库结构。