# InnoDB 中 B+ 树的查找过程

[toc]

## 简介

MySQL 的 InnoDB 存储引擎默认使用 B+ 树结构来组织和管理表中数据，特别是索引。B+ 树是一种平衡树结构，适合存储大规模的、需要高效检索的数据。通过 B+ 树的方式，InnoDB 可以在稳定的时间复杂度内实现高效的增删改查操作。本文将分别从聚簇索引和非聚簇索引（单列索引和组合索引）来介绍 B+ 树的查找过程，

---

## B+ 树查找过程

在 B+ 树中，查找过程通常是从根节点开始，逐层向下直到找到目标叶子节点。具体步骤如下：

1. **从根节点开始**：根节点存储了该层的所有索引键值，并指向下一层的中间节点。查找操作从根节点开始，根据键值范围决定下一步进入哪一个中间节点。
2. **逐层查找**：进入对应的中间节点后，继续根据键值范围选择下一个节点，直到达到叶子节点。
3. **定位叶子节点**：一旦到达叶子节点，直接在叶子节点中查找目标记录。由于 B+ 树的叶子节点按照键值顺序存储，所以可以快速定位到目标记录。
4. **返回结果**：查找到目标记录后，返回该记录的内容。

查找过程的简要示意图：

~~~markdown
       根节点
        /  \
    中间节点  中间节点
      /  \    /  \
  叶子节点  叶子节点  叶子节点  叶子节点

~~~

---

## 聚簇索引的查找过程

### 数据页数据存储

所有插入表的数据最终都要持久化到磁盘上，InnoDB 为了方便管理这些数据，提出了 **页** 的概念，它会将数据划分到多个页中，每个页大小默认是16KB，这个页我们可以称为数据页。数据页除了存储数据还会存储一些额外的信息，这里不做过多介绍。

当我们插入一条数据的时候，数据都会存在数据页中，如下图左侧数据页所示。

当数据不断地插入，数据页中的数据不断增多时，数据会根据主键（没有的话会隐式的自动生成）的大小进行排序，形成一个单向链表，如下图右侧数据页所示。

![image-20240905110200557](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240905110200557.png)

### 单个数据页的数据查找

现在以需要在数据页中定位到 `id=2` 的这条记录为例，说一下查找过程。

首先，有一种简单粗暴的方法就是从头开始遍历链表遍，判断 `id` 是不是等于 2，如果等于 2 就取出数据。

虽然这种方法可行，但是如果一个数据页存储的数据过多，每次都要遍历，不但麻烦而且会增加耗时。

MySQL 的解决方案是给数据分组，假设数据页中存了 12 条数据，那么整个分组大致如下图所示：

![image-20240905111015127](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240905111015127.png)

为了简便，上图中只标出了 `id` 值，省略了其它字段的值。下面简单说一下对于数据分组的理解：

上面 12 条数据中，假设每 4 条数据算一个组，就有3个组。分好组之后，MySQL 会取出每组中 `最大的id` 值，就是图中的 4、8、12，把它们放在一起，在数据页中找个位置存起来，这就是**页目录**。

假设此时要查询 `id=6` 的数据，此时只需要从页目录中根据二分查找，发现在 [4, 8] 之间，由于 4 和 8 是他们所在分组的最大的 `id`，那么 `id=6` 肯定在 8 那个分组中，之后就会到 `id=8` 的那个分组中，遍历每个数据，判断id是不是等于6即可。

虽然也是会遍历数据，但是由于 MySQL 规定每个组的数据条数大概为4~8条，所以肯定比遍历整个数据页的数据快的多。

### 多个数据页中的数据查找

当表中的数据不断增多的时候，数据占用空间就会越来越大，但是一个数据页的大小是一定的，只有 16K。当数据在一个数据页中放不开时，MySQL 就会重新创建一个数据页来存储数据。

MySQL 为了对每个数据页进行区分，会为每个数据页分配一个页号，存储在数据页中，同时还会存储当前数据页的前一个和后一个数据页的位置，从而形成数据页之间的双向链表，如下图：

![image-20240905112454743](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240905112454743.png)

可以理解为：数据页 2 的页号就是 2，数据页 3 的页号就是 3。

同时 MySQL 规定，前一个数据页的存储数据 `id的最大值` 要小于后一个数据页的存储数据 `id的最小值`，这样就实现了数据在所有数据页中**按照 id 大小的排序**。

现在，如上图所示，有 2 个数据页，此时以要查找 `id=5` 的数据为例，说一下查找过程。

首先，当然可以从第一个数据页开始进行遍历，直到查找到 `id=5` 的数据。但是如果表中数据量很大，而且要查找的是最后一个数据页的最后一条数据，这种方式相当于全表扫描，十分耗时。

MySQL 对此的优化方式是：将每个数据页中 `最小的id` 拿出来，单独放到另一个数据页中，这个数据页不存储我们实际插入的数据，只存储 `最小的id` 和这个 `id` 所在数据页的页号，如图所示：

![image-20240905134452808](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240905134452808.png)

此时数据页 5 就是抽取出来的，存放了数据页 2、数据页 3、数据页 4 的`最小的 id` 和所在数据页的页号。

如果此时查找 `id=5` 的数据，大致分为以下几个步骤：

- 从数据页 5 直接根据二分查找，发现在 [4, 7] 之间。
- 由于 4 和 7 是所在数据页 `最小的id` ，那么此时 `id=5` 的数据必在 `id=4` 的数据页上(因为 `id=7` 的数据页 `最小的id` 就是 7)。
- 接下来根据 `id=4` 找到对应的数据页的页号，定位到数据页 2。
- 最后再根据前面提到的根据数据的 `主键id` 从单个数据页查找的流程查找数据。

这样就实现了根据 `主键id` 到在多个数据页之间查找数据，可以发现，多数据页的查询优化和单数据页的优化思路差不多。

其实对于索引本身来说，我们可以理解为书的目录，无论是单数据页的**页目录**还是多数据页的**页号**，都可以把它们当成是具体内容的一个总览，相当于书的目录的大标题等。

---

## 单列索引

本节以单列普通索引为例子，简单说明 B+树的查找流程。对于单列普通索引也会根据聚簇索引一样，在单个或多个数据页中进行数据的查找。所以本节不在细化到数据页的说明，统一使用磁盘块代替。

假设有以下表结构，并且初始化了这几条数据

```sql
CREATE TABLE `employee` (
  `id` int(11) NOT NULL,
  `name` varchar(255) DEFAULT NULL,
  `age` int(11) DEFAULT NULL,
  `date` datetime DEFAULT NULL,
  `sex` int(1) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `idx_age` (`age`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

insert into employee values(100,'张三',43,'2021-01-20','0');
insert into employee values(200,'李四',48,'2021-01-21','0');
insert into employee values(300,'王五',36,'2020-01-21','1');
insert into employee values(400,'赵六',32,'2020-01-21','0');
insert into employee values(500,'钱七',37,'2020-01-21','1');
insert into employee values(600,'孙八',49,'2021-01-21','0');
insert into employee values(700,'周世',28,'2021-01-21','1');
```

以执行这条查询 SQL 为例，说一下查找过程。

```sql
select * from Temployee where age=32;
```

首先，使用的索引是 `idx_age`，可以先画出 `idx_age` 普通索引的索引结构图，大概如下：

![image-20240719110623290](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240719110623290.png)

像上面在聚簇索引中所说，MySQL 会根据 `age` 字段的值进行排序，当索引值相同时，会根据 `id` 排序。接着再画出 `id` 主键索引（聚簇索引），我们先画出聚族索引结构图，如下：

![image-20240719110634734](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240719110634734.png)

这条 SQL 查询语句执行大概流程是这样的：

- 搜索 `idx_age` 索引树，将`磁盘块1`加载到内存，由于 `32<43`，搜索左路分支，到磁盘寻址`磁盘块2`。
- 将`磁盘块2`加载到内存中，由于 `32<36`，搜索左路分支，到磁盘寻址`磁盘块4`。
- 将`磁盘块4`加载到内存中，在内存继续遍历，找到 `age=32` 的记录，取得 `id = 400`。
- 拿到 `id=400` 后，回到`id主键索引树`。
- 搜索 `id主键索引树`，将`磁盘块1`加载到内存，因为 `300<400<500`，所以在选择中间分支，到磁盘寻址`磁盘块3`。
- 虽然在`磁盘块3`，找到了 `id=400`，但是它不是叶子节点，所以会继续往下找，直到磁盘寻址`磁盘块8`。
- 将`磁盘块8`加载内存，在内存遍历，找到 `id=400` 的记录，拿到`R4`这一行的数。

---

## 组合索引

联合索引其实和单列索引是一样的，只不过是多存了一些索引列，而且会根据索引列的值进行整体排序。

比如，在 `name` 和 `age` 上建立一个联合索引，此时单个索引页就如图所示：

![image-20240905155457451](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240905155457451.png)

排序规则：先以 `name` 排序，`name` 相同时再以 `age` 排序，如果再有其它列，依次类推，最后再以 `id` 排序。

可以发现，和单列索引相比，索引页中只是多了一个索引列，最后形成的B+树简化为如下图：

![image-20240905155634490](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240905155634490.png)

---

## B+ 树的增长与收缩

B+ 树的结构是动态的，随着数据的插入、更新和删除，树的高度和形态会不断调整，以保持平衡和高效。B+ 树的增长和收缩主要通过以下两个操作实现：

1. **分裂（Split）**：当一个节点的键值超出了节点的容量限制，InnoDB 会将该节点分裂为两个节点，并将其中一部分键值移入新节点，最后将新节点的指针信息更新到父节点中。如果父节点也满了，递归进行分裂操作，最终可能影响到根节点，增加树的高度。
2. **合并（Merge）**：当大量数据被删除，导致节点的利用率过低时，InnoDB 会将相邻的两个节点进行合并，减少树的高度，节约存储空间。

---

## 总结

B+ 树在 MySQL 的 InnoDB 存储引擎中起到了至关重要的作用。它通过高度平衡的多路树结构，保证了高效的增删改查性能。无论是主键索引还是二级索引，B+ 树都能够在 O(log N) 的时间复杂度内完成查找操作。理解 B+ 树的工作原理和增长机制，能够帮助我们更好地进行数据库设计与优化。



