# MySQL 索引的增删改查操作原理

[toc]



## 简介

MySQL 使用多种数据结构来实现不同类型的索引，分别有： B Tree 结构、B+ Tree 结构、哈希表结构、倒排索引结构和 R Tree 结构，上一篇介绍了每种数据结构的结构特点、优缺点和使用场景，这一篇来说一下每种数据结构在执行增删改查时的操作流程。

---

## B Tree 结构

B-Tree 是一种平衡树结构，广泛用于数据库和操作系统中，用于存储和管理大块数据。

### 查找（Search）

从根节点开始，通过比较键值（二分查找），沿着合适的子节点指针向下移动，直到找到目标键值或到达叶子节点。

1. 从根节点开始，比较索引键（二分查找）。
2. 根据索引键的大小，选择指向相应子节点的指针。
3. 递归地在子节点中查找，直到找到目标索引键（内部节点也可以存储完整数据）或到达叶子节点。

### 插入（Insert）

找到适当的插入位置，将新键值插入。如果节点已满，需要进行节点分裂。

1. 查找到适当的叶子节点插入新索引键。
2. 如果叶子节点有空间，直接插入。
3. 如果叶子节点没有空间，分裂叶子节点，将中间索引键提升到父节点。
4. 递归地处理父节点的分裂，直到根节点。

### 删除（Delete）

找到并删除目标键值。如果删除后节点低于最小键值数，需要进行节点合并或借位操作。

1. 查找到目标索引键所在的叶子节点。
2. 删除索引键，并调整节点。
3. 如果节点元素过少，需要合并节点或从相邻节点借元素。
4. 递归地调整父节点，直到根节点。

### 更新（Update）

找到目标键值的位置，并更新对应的值。

1. 查找到目标索引键所在的节点。
2. 修改索引键对应的数据。
3. 如果索引键发生变化，可能需要删除旧索引键并插入新索引键。

---

## B+ Tree 结构

B+ Tree 是一种平衡树结构，所有叶子节点都在同一层，叶子节点存储数据记录，并通过链表连接。B+ Tree 是 MySQL 的默认索引类型，特别是在 InnoDB 存储引擎中。

### 查找（Search）

从根节点开始，通过比较键值，沿着合适的子节点指针向下移动，直到找到目标键值或到达叶子节点。

1. 从根节点开始，根据索引键逐层向下查找。
2. 在每层节点中，通过比较索引键，选择指向下层节点的指针。
3. 最终在叶子节点中找到目标索引键，并通过指针找到对应的数据记录（B+ Tree 只在叶子结点存储完整数据，所以必须到达叶子结点，而 B Tree 则不必达到叶子结点）。

### 范围查询（Range Query）

从根节点开始，找到起始的叶子结点，通过叶子结点进行范围查询。

1. 从根节点开始，通过索引键查找到范围起点的叶子节点。
2. 从起点叶子节点开始，通过双向链表遍历叶子节点，直到范围终点。

### 插入

找到适当的插入位置，将新键值插入叶子节点。如果节点已满，需要进行节点分裂，并将中间键值上移到父节点。

1. 通过查找操作，找到适当的位置插入新的索引键。
2. 如果叶子节点有空间，直接插入。
3. 如果叶子节点没有空间，分裂叶子节点并将中间索引键提升到父节点。
4. 可能会引起父节点的分裂，递归分裂直到根节点。

### 删除

找到并删除目标键值。如果删除后节点低于最小键值数，需要进行节点合并或借位操作。

1. 查找到目标索引键所在的叶子节点。
2. 删除索引键并调整节点。
3. 如果节点元素过少（低于阈值），需要合并节点或从相邻（兄弟）节点借元素。
4. 同样可能会递归调整父节点，直到根节点。

### 更新

找到目标键值的叶子节点，并更新对应的值。

1. 查找到目标索引键所在的节点。
2. 修改索引键对应的数据。
3. 如果索引键发生变化，可能需要删除旧索引键并插入新索引键。

---

## 哈希表结构

哈希索引基于哈希表实现，主要用于等值比较查询，即精确匹配搜索。它不保持数据的任何排序顺序，而是直接通过计算键的哈希值来定位数据行。哈希索引和 Java 中的 HashMap 的底层结构比较像，Key 是哈希值，Value 是一个链表。

### 查找（Search）

通过哈希函数计算键值的哈希值，直接定位到哈希表中的槽位，并在槽位中查找目标键值。

1. 使用哈希函数计算索引键的哈希值。
2. 根据哈希值找到对应的桶（哈希表的槽位）。
3. 在桶中（链表）查找目标索引键，找到后返回数据指针。

### 插入（Insert）

通过哈希函数计算新键值的哈希值，将新键值插入到对应的槽位。

1. 使用哈希函数计算新索引键的哈希值。
2. 根据哈希值找到对应的桶。
3. 在桶中插入新索引键和数据指针。

### 删除（Delete）

通过哈希函数计算键值的哈希值，从哈希表的槽位中删除目标键值。

1. 使用哈希函数计算索引键的哈希值。
2. 根据哈希值找到对应的桶。
3. 在桶中删除目标索引键和数据指针。

### 更新（Update）

通过哈希函数计算键值的哈希值，在哈希表的槽位中找到目标键值，并更新对应的值。

1. 使用哈希函数计算索引键的哈希值。
2. 根据哈希值找到对应的桶。
3. 在桶中更新索引键对应的数据指针。

---

## 倒排索引结构

倒排索引用于全文搜索，特别适合处理大量文本数据。

### 查找（Search）

通过关键词在倒排索引中查找关键词对应的文档ID列表。

1. 在词典中查找目标词条。
2. 获取词条对应的倒排列表。
3. 在倒排列表中找到包含该词条的文档标识符和位置（文档列表）。

### 插入（Insert）

将新文档中的关键词添加到倒排索引中，更新关键词对应的文档ID列表。

1. 将文档中的每个词条添加到词典中。
2. 更新词条对应的倒排列表，添加文档标识符和位置。

### 删除（Delete）

从倒排索引中删除文档ID，并更新相应的关键词列表。

1. 在词典中查找到需要删除词条的倒排列表。
2. 从倒排列表中移除对应的文档标识符和位置。
3. 如果倒排列表为空，可以选择删除词条。

### 更新（Update）

更新文档中的关键词信息，并更新倒排索引。

1. 删除旧文档中每个词条的索引。
2. 将新文档中的每个词条插入到词典中并更新倒排列表。

---

## R-Tree 结构

R-Tree 是一种用于空间数据索引的树结构，特别适合地理信息系统（GIS）中的空间查询。

### 查找（Search）

从根节点开始，通过比较空间对象的边界框，沿着合适的子节点指针向下移动，直到找到目标对象。

1. 从根节点开始，比较查询对象的最小边界矩形（MBR）。
2. 根据 MBR，选择指向相应子节点的指针。
3. 递归查找，直到找到目标对象的叶子节点。

### 插入（Insert）

找到适当的插入位置，将新对象插入。如果节点已满，需要进行节点分裂。

1. 查找到适当的叶子节点插入新对象的 MBR。
2. 如果叶子节点有空间，直接插入。
3. 如果叶子节点没有空间，分裂叶子节点，将中间 MBR 提升到父节点。
4. 递归处理父节点的分裂，直到根节点。

### 删除（Delete）

找到并删除目标对象。如果删除后节点低于最小限制，需要进行节点合并。

1. 查找到目标对象的叶子节点。
2. 删除对象的 MBR，并调整节点。
3. 如果节点元素过少，需要合并节点或从相邻节点借元素。
4. 递归调整父节点，直到根节点。

### 更新（Update）

找到目标对象的位置，并更新对应的边界框。

1. 删除旧对象的 MBR。
2. 插入新对象的 MBR。

---

## 对比

| 特性           | B Tree               | B+ Tree                              | 哈希表                 | 倒排索引           | R Tree                     |
| -------------- | -------------------- | ------------------------------------ | ---------------------- | ------------------ | -------------------------- |
| **查找效率**   | O(log n)             | O(log n)                             | O(1)                   | O(1) 或 O(log n)   | O(log n)                   |
| **插入效率**   | O(log n)             | O(log n)                             | O(1)                   | O(1) 或 O(log n)   | O(log n)                   |
| **删除效率**   | O(log n)             | O(log n)                             | O(1)                   | O(1) 或 O(log n)   | O(log n)                   |
| **更新效率**   | O(log n)             | O(log n)                             | O(1)                   | O(1) 或 O(log n)   | O(log n)                   |
| **范围查询**   | 不支持               | 支持                                 | 不支持                 | 不支持             | 支持                       |
| **空间利用率** | 高                   | 较高                                 | 较高                   | 高                 | 较高                       |
| **适用场景**   | 需要平衡树结构的索引 | 大多数查询场景，特别是排序和范围查询 | 需要高效等值查询的场景 | 全文搜索，文本查询 | 地理空间数据查询，GIS 应用 |

### 查找效率

- **B-Tree**：适合大多数类型的查询，特别是精确查找。
- **B+Tree**：比 B-Tree 更适合范围查询和顺序访问。
- **哈希表**：等值查找效率最高，但不支持范围查询。
- **倒排索引**：适用于全文搜索，非常高效地查找包含某些关键词的文档。
- **R-Tree**：专为多维空间数据设计，适合地理位置和多维空间数据查询。

### 插入效率

- **B-Tree 和 B+Tree**：插入操作复杂度较高，需要保持树的平衡。
- **哈希表**：插入操作非常高效，但需要处理哈希冲突。
- **倒排索引**：插入操作涉及更新多个关键词的文档ID列表，复杂度较高。
- **R-Tree**：插入操作较复杂，需要调整空间对象的边界框并保持树的平衡。

### 删除效率

- **B-Tree 和 B+Tree**：删除操作复杂，需要保持树的平衡。
- **哈希表**：删除操作较为简单，但需要处理哈希冲突后的再平衡。
- **倒排索引**：删除操作涉及从多个关键词的文档ID列表中删除文档ID，复杂度较高。
- **R-Tree**：删除操作复杂，需要调整空间对象的边界框并保持树的平衡。

### 更新效率

- **B-Tree 和 B+Tree**：更新操作类似于删除和插入的组合，复杂度较高。
- **哈希表**：更新操作高效，但需要处理哈希冲突。
- **倒排索引**：更新操作涉及删除旧文档关键词和添加新文档关键词，较为复杂。
- **R-Tree**：更新操作复杂，需要重新计算边界框，并可能涉及删除和插入操作。

---

## 总结

- **B Tree 和 B+ Tree**：B+ Tree 是 B Tree 的改进版本，主要区别在于 B+ Tree 的叶子节点通过链表连接，支持更高效的范围查询和顺序扫描。B+ Tree 更适合数据库的索引结构，是 MySQL 中的常用索引类型。
- **哈希表**：适合等值查询，不支持范围查询。哈希表在内存中效率极高，但在磁盘上的性能不如 B+ Tree。
- **倒排索引**：专门用于全文搜索，适合处理文本数据。倒排索引在查找包含特定词条的文档时非常高效，但不适合其他类型的查询。
- **R Tree**：适用于空间数据的索引和查询，主要用于 GIS 应用。R Tree 支持复杂的空间查询，如点、线、多边形的交叉、包含等操作。

不同的数据结构有不同的优势和应用场景，选择合适的索引结构可以显著提高数据库的性能。