# 快照读与当前读

[toc]

## 简介

在 MySQL 的 InnoDB 存储引擎中，读操作可以分为两种类型：当前读（Current Read）和快照读（Snapshot Read）。这两种读取方式与事务的隔离级别和多版本并发控制（MVCC）密切相关，在并发控制和数据一致性方面有不同的实现方式和应用场景。

---

## 快照读（Snapshot Read）

### 简介

快照读是一种读取数据的方式，读取的始终是事务开始时的一致性快照，即读取的数据版本是事务启动时系统中各记录的状态。

这种读取方式不会看到其他并发事务对数据做出的更改，即使这些更改已经提交。快照读是 MVCC 机制的核心，它允许事务读取到一致性的数据快照，从而提供非锁定读取，避免了读-写冲突。

### 实现方式

- **MVCC**：通过多版本并发控制（MVCC）实现，使用一致性视图（Read View）来确定数据的可见性。
- **隐藏列**：每条记录包含两个隐藏列 `DB_TRX_ID` 和 `roll_pointer`。`DB_TRX_ID` 表示创建或修改该记录的事务 ID，`roll_pointer` 指向前一个版本的数据。
- **版本链**：当一条记录被更新时，旧版本的数据会被保存到回滚段（Undo Log），并通过 `roll_pointer` 链接形成版本链。

### 操作

- **SELECT 操作**：普通的 `SELECT` 语句（没有锁定子句，如 `FOR UPDATE` 或 `LOCK IN SHARE MODE`）会触发快照读。
- **一致性视图**：事务启动时创建一致性视图，记录当前系统中的活跃事务 ID 列表及相关信息。读取数据时，通过一致性视图判断哪些版本数据对当前事务可见。
- **遍历版本链**：如果当前版本不可见，通过 `roll_pointer` 查找前一个版本，直到找到可见版本。

### 使用场景

- **高并发读操作**：在需要高并发读取且保证一致性视图的场景下，快照读是非常有效的。
- **可重复读（REPEATABLE READ）隔离级别**：默认使用快照读，确保事务期间读取的数据一致性，避免幻读。

### 优点

- **无锁读**：快照读不需要加锁，可以在高并发环境下实现高性能的读取。
- **一致性视图**：在事务期间提供一致性视图，保证读取数据的一致性。

### 缺点

- **版本链开销**：需要维护版本链和回滚段数据，可能增加存储和性能开销。
- **长事务问题**：长时间运行的事务可能导致回滚段膨胀，占用更多的系统资源。

### 快照读与隔离机制

快照读在 `REPEATABLE READ` 和 `READ COMMITTED` 这两个隔离级别下的表现略有不同：

- 在 `REPEATABLE READ` 隔离级别下（MySQL 默认级别），快照在事务开始时创建，之后该事务的所有快照读都会看到这个快照中的数据。
- 在 `READ COMMITTED` 隔离级别下，快照读每次查询时都会创建一个新的数据快照，因此可能看到其他已提交事务的更改。

---

## 当前读（Current Read）

### 定义

当前读是一种读取数据的方式，读取的是记录的最新版本，并对读取的数据加锁，确保在读取和处理期间数据不被其他事务修改。当前读会看到其他已提交事务的更改。

### 实现方式

- **加锁读取**：通过加锁机制实现当前读，确保读取的数据是最新的版本，并防止其他事务并发修改。
- **锁类型**：当前读会使用排他锁（X 锁）或共享锁（S 锁），具体取决于语句类型和需求。

### 操作

- 加锁操作：
  - `SELECT ... FOR UPDATE`：对读取的行加排他锁，防止其他事务修改或删除这些行。
  - `SELECT ... LOCK IN SHARE MODE`：对读取的行加共享锁，允许其他事务读取但不允许修改这些行。
  - `INSERT`：当执行 `INSERT` 操作时，InnoDB 会创建一个新的数据行，并为其分配一个唯一的事务 ID。这个新行对于其他未提交的事务是不可见的。因此，`INSERT` 操作会触发当前读，因为它需要读取当前的事务 ID 来确保新插入的行对于其他事务是不可见的。
  - `UPDATE`：`UPDATE` 操作实际上是一个删除旧行和插入新行的组合操作。在执行 `UPDATE` 时，InnoDB 首先读取并锁定旧行（当前读），然后创建一个新行，更新其内容，并为其分配新的事务 ID。这个新行对于其他未提交的事务是不可见的。因此，`UPDATE` 操作也会触发当前读。
  - `DELETE`：`DELETE` 操作涉及到读取并锁定要删除的行（当前读），然后将其标记为删除状态，并记录删除操作的事务 ID。这个被标记删除的行对于其他未提交的事务是不可见的。因此，`DELETE` 操作同样会触发当前读。
- **立即读取最新数据**：当前读确保读取的是最新版本的数据，如果有并发事务正在修改这些数据，会等待锁释放后再读取。

### 使用场景

- **数据更新场景**：在需要读取后立即更新数据的场景下，当前读确保读取的是最新版本，并防止并发修改。
- **防止幻读**：在某些隔离级别下（如可重复读或序列化），通过当前读和加锁机制防止幻读现象。

### 优点

- **数据一致性**：确保读取的数据是最新的，适合需要数据一致性的场景。
- **防止并发修改**：通过加锁机制防止并发事务修改数据，确保数据安全。

### 缺点

- **锁等待**：加锁会导致其他并发事务等待，可能影响系统性能和并发性。
- **死锁风险**：加锁操作增加了死锁的风险，需要额外的死锁检测和处理机制。

---

## 对比总结

| 特性         | 快照读（Snapshot Read）        | 当前读（Current Read）                     |
| ------------ | ------------------------------ | ------------------------------------------ |
| **实现机制** | MVCC，一致性视图，版本链       | 加锁机制（共享锁或排他锁）                 |
| **读取数据** | 一致性视图中的数据版本         | 最新版本数据                               |
| **操作类型** | 普通 SELECT 语句               | SELECT ... FOR UPDATE / LOCK IN SHARE MODE |
| **加锁情况** | 无锁读                         | 加锁读                                     |
| **性能**     | 高并发读取，高性能             | 可能导致锁等待，影响并发性                 |
| **一致性**   | 事务期间一致性视图             | 确保读取到最新数据                         |
| **使用场景** | 高并发读操作，可重复读隔离级别 | 数据更新场景，防止幻读                     |
| **优点**     | 高并发性能，无锁读             | 确保数据一致性，防止并发修改               |
| **缺点**     | 版本链和回滚段开销，长事务问题 | 锁等待，死锁风险                           |

通过对比，可以看到快照读和当前读在实现方式、性能、数据一致性和使用场景方面各有优势和劣势。根据具体的应用需求和并发控制要求，选择适当的读操作方式，可以在保证数据一致性的同时，最大化系统性能和并发性。