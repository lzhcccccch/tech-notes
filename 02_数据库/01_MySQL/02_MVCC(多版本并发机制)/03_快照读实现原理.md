# MVCC 机制快照读实现原理

[toc]

## 简介

MySQL 中的 MVCC（Multiversion Concurrency Control）机制通过快照读来实现高并发环境下的事务一致性和隔离性。快照读的实现依赖于一致性视图（Read View）和数据版本链（Version Chain），以确保在事务执行期间读取到的总是同一版本的数据。

快照读是一种能无需加锁的读取方式，从而允许读写操作并发执行而不互相阻塞。

可以说，快照读是 MVCC 实现的基础，而当前读是悲观锁实现的基础

---

## 快照如何存储

在 MySQL 的 InnoDB 存储引擎中，每次事务开始时，会创建一个一致性视图（Read View），记录当前系统中所有活跃事务的事务 ID 列表及相关信息。一致性视图存储了事务开始时的系统状态，用于确定在整个事务期间哪些数据版本对当前事务可见。

一致性视图包含以下内容：

- **`m_ids`**：当前系统中所有活跃事务的 ID 列表。这些事务在一致性视图创建时尚未提交（注意，这里的每一个事务都会对应一个 ReadView，当前事务最终读取的就是事务对应（或版本链中）的 ReadView 的数据）。
- **`min_trx_id`**：`m_ids` 中最小的事务 ID。这是当前活跃的最早的事务 ID。
- **`max_trx_id`**：当前系统中将要分配的下一个事务 ID。表示创建一致性视图时的最新事务 ID。
- **`creator_trx_id`**：创建一致性视图的事务 ID。

数据行的版本信息通过两个隐藏列来存储：

- **`DB_ROW_ID`**：隐藏主键，如果没有给表创建主键，那么会以这个字段来创建聚簇索引。

- **`DB_TRX_ID`**：表示创建或修改该版本数据的事务 ID。
- **`roll_pointer`**：指向回滚段中的前一个版本数据，用于形成版本链。

一致性视图的存储方式并不是直接存储数据的快照，而是通过存储事务ID和版本链来间接实现数据版本的一致性读取。

---

## 快照存储位置

一致性视图本身是存储在内存中的，而数据版本则存储在回滚段（Undo Logs）中。每次事务修改数据时，旧版本的数据会被保存在回滚段中，并通过版本链（Version Chain）形成一个数据版本链。

- **回滚段（Undo Logs）**：回滚段存储在系统表空间（System Tablespace）中，包含所有未提交事务的旧版本数据。每个数据行都有一个隐藏的 `roll_pointer`，指向回滚段中的上一个版本。每次数据修改时，旧版本的数据会保存在回滚段中，并通过 `roll_pointer` 指向前一个版本，形成版本链。
- **内存**：一致性视图存储在内存中，它包含了活跃事务的 ID 列表和其他相关信息。

通过这种方式，InnoDB 可以通过回滚段中的旧版本数据和内存中的一致性视图，来实现快照读。

数据的当前版本存储在数据库的主数据区域中，而它的历史版本（也就是快照）存储在 undo 日志中。

![image-20240611152545443](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240611152545443.png)

---

## 多个快照如何读取

当多个事务同时执行并创建快照时，每个事务都有自己的一致性视图。快照读的具体实现过程如下：

1. **创建一致性视图**：

   事务启动时，InnoDB 创建一个一致性视图，记录当前系统中的活跃事务ID（`m_ids`），以及最小事务ID（`min_trx_id`）和下一个事务ID（`max_trx_id`）。

2. **读取数据**：

   读取数据时，InnoDB 会根据一致性视图来判断哪个版本对当前事务可见。具体步骤如下：

   - 如果数据版本（要读取的数据行）的 `DB_TRX_ID` 小于 `min_trx_id`（当前事务开始时创建的一致性视图中的 `min_trx_id`），表示这个版本（要读取的数据行）在当前事务开始之前就已经提交了，所以这个版本（要读取的数据行）对当前事务是可见的。
   - 如果数据版本的 `DB_TRX_ID` 大于或等于 `max_trx_id`，表示这个版本在当前事务开始之后才创建，所以是不可见的。
   - 如果数据版本的 `DB_TRX_ID` 在 `min_trx_id` 和 `max_trx_id` 之间，则需要进一步检查该 `DB_TRX_ID` 是否在 `m_ids` 中：
     - 如果在，表示这个版本是由一个尚未提交的事务创建的，所以是不可见的。
     - 如果不在，则表示这个版本是由一个已经提交的事务创建的，所以是可见的。

3. **沿版本链查找**：

   如果当前版本对事务不可见，InnoDB 会沿着版本链（通过 `roll_pointer` 指针）查找上一个版本，重复上述判断过程，直到找到一个对当前事务可见的版本。

![image-20240611152858881](https://raw.githubusercontent.com/lzhcccccch/MyNotes/main/img/image-20240611152858881.png)

4. **小结**：
   - 事务 A 开启时，会创建自己的一致性视图 RW1。
   - 事务 A 要读取行 ROW1 的数据，ROW1 是数据版本，用 ROW1 所对应的 `DB_TRX_ID` 和事务 A 的一致性视图 RW1 中属性作对比，看是否符合；不符合则根据 ROW1 的 `roll_pointer` 来查找上一个版本继续判断。

---

## 示例

假设表 `example` 中有如下数据和事务：

```sql
CREATE TABLE example (
    id INT PRIMARY KEY,
    value VARCHAR(50)
);

INSERT INTO example (id, value) VALUES (1, 'A'), (2, 'B'), (3, 'C');
```

1. **当前系统状态**：

   - 事务A（ID=10）正在进行。
   - 事务B（ID=11）正在进行。
   - 事务C（ID=12）正在进行。

2. **事务D（ID=13）启动并创建一致性视图**：

   - `m_ids` = [10, 11, 12]
   - `min_trx_id` = 10
   - `max_trx_id` = 13
   - `creator_trx_id` = 13

3. **事务B 更新数据**：

   ```sql
   START TRANSACTION;
   UPDATE example SET value = 'B' WHERE id = 1;
   COMMIT;
   ```

   - `id=1` 记录的 `DB_TRX_ID` 更新为 11。

4. **事务C 更新数据**：

   ```sql
   START TRANSACTION;
   UPDATE example SET value = 'C' WHERE id = 1;
   COMMIT;
   ```

   - `id=1` 记录的 `DB_TRX_ID` 更新为 12。

5. **事务D 读取数据**：

   ```sql
   SELECT * FROM example WHERE id = 1;
   ```

   - 读取 `id=1` 的记录时，InnoDB 会检查当前版本的 `DB_TRX_ID`，即 12。
   - 根据一致性视图判断：
     - `DB_TRX_ID` (12) 在 `min_trx_id` (10) 和 `max_trx_id` (13) 之间。
     - `DB_TRX_ID` (12) 在 `m_ids` 列表中，因此对事务D 不可见。
   - InnoDB 通过 `roll_pointer` 指向前一个版本，继续判断：
     - 前一个版本的 `DB_TRX_ID` 是 11。
     - `DB_TRX_ID` (11) 也在 `min_trx_id` (10) 和 `max_trx_id` (13) 之间，且在 `m_ids` 列表中，因此对事务D 也不可见。
   - 再次通过 `roll_pointer` 指向更前一个版本：
     - 更前一个版本的 `DB_TRX_ID` 是创建表时的数据版本，未被任何事务修改。
     - `DB_TRX_ID` (创建表时) 小于 `min_trx_id` (10)，因此对事务D 可见。

最终，事务D 读取到的数据版本是 `value='A'`，这是在事务A、B、C 开始前的数据版本。

---

## 总结

MySQL 的 MVCC 机制通过一致性视图和版本链管理，实现了高并发环境下的数据一致性读取。快照读通过在事务启动时创建的一致性视图，结合存储在回滚段中的旧版本数据，实现了事务期间数据的一致性视图读取。在多个快照同时存在时，通过遍历版本链并结合一致性视图的信息，确定当前事务可见的数据版本，从而实现了快照读的高效并发控制。