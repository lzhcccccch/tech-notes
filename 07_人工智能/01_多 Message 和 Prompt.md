# 多消息和 Prompt 对比

[toc]

## 概念介绍

### 多 Message 方式

**多 Message** 方式是通过构建一系列消息对象来与 LLM 进行交互，每个消息都有明确的角色（如 system、user、assistant）。

多 Message 方式强调“对话历史”，适用于需要上下文连续、多轮对话、角色扮演等场景。

**典型用法：**  

```java
List<Message> messages = Arrays.asList(
    new SystemMessage("你是一个专业的翻译助手。"),
    new UserMessage("请将下面这句话翻译成英文：你好，世界！")
);
String result = llm.chat(messages);
```

**特点：**

- **结构化清晰**：每个消息都有明确的角色定义
- **上下文管理**：可以轻松管理对话历史
- **灵活性高**：可以精确控制每条消息的内容和顺序

### Prompt 方式

Prompt 方式是通过构建一个格式化的提示词模板，直接向 LLM 发送请求。

**Prompt** 方式强调“单轮输入”，适用于一次性任务、模板化输出、无需多轮上下文的场景。

**典型用法：**  

```java
String prompt = "你是一个专业的翻译助手。\n请将下面这句话翻译成英文：你好，世界！";
String result = llm.generate(prompt);
```

---

## 用法对比

| 方式       | 主要用途       | 代码结构       | 上下文管理 | 灵活性       |
| ---------- | -------------- | -------------- | ---------- | ------------ |
| 多 Message | 多轮对话、角色 | List\<Message> | 内建上下文 | 高（可扩展） |
| Prompt     | 单轮任务、模板 | 单字符串       | 需手动拼接 | 简单直接     |

---

## 优缺点分析

### 多 Message

**优点：**
- 易于管理多轮对话和上下文。
- 支持不同角色（如 system, user, assistant）。
- 更贴近 OpenAI Chat API 的原生用法。

**缺点：**

- 代码稍复杂，需要管理 Message 列表。
- 对于简单任务略显冗余。

### Prompt

**优点：**
- 简单直接，适合一次性任务。
- 更接近传统的 prompt engineering。

**缺点：**
- 不方便管理多轮对话，需手动拼接上下文。
- 不支持多角色分离，灵活性有限。

---

## 场景举例

| 场景                     | 推荐方式   | 理由                           |
| ------------------------ | ---------- | ------------------------------ |
| 聊天机器人               | 多 Message | 需多轮对话、角色分明           |
| 单次文本摘要、翻译等任务 | Prompt     | 一次性输入输出，结构简单       |
| 复杂的系统指令           | 多 Message | 可以用 system message 指定规则 |
| 模板化批量生成           | Prompt     | 只需拼接模板即可，易于自动化   |

---

## 总结

- **多 Message**：适合复杂、多轮、需要角色分离和上下文的应用。
- **Prompt**：适合简单、单轮、模板化的应用。

如果项目有多轮对话需求，建议优先考虑**多 Message**方式，会让代码更清晰、可维护性更高。

如果只是做简单的 prompt 试验或一次性任务，**Prompt**方式更为快捷。