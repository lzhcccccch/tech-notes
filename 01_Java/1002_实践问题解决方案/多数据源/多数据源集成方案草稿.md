## 多数据源集成方案

[toc]

#### 业务背景

由单一的数据库拆分为三个数据库，分别为主库，以及两个业务从库。主库存放公共数据，比如角色、权限、租户数据源等。拆分出从库之后，相当于多租户模式，可以实现租户的独立部署和业务数据私有化。

---

---

#### 方案简介

基于当前系统使用的 Druid 连接池和 mybatis 实现多数据源的切换，主要实现两方面：

1. 实现可以利用注解进行数据源切换，并支持嵌套调用（ServiceA >>> ServiceB >>> ServiceC）。

2. 对所有的前端请求进行拦截，通过用户的租户信息来切换数据源。用户登录时将该用户的默认租户添加到用户信息中，一起放到 Redis 中，并对所有的 Controller 进行 AOP 增强，获取到该用户的租户，设置相应的数据源。

   

不采用开源框架dynamic-datasource-spring-boot-starter说明：

1. 该框架可以实现功能 1，不支持功能 2，仍需自己实现。
2. 该框架的代码开源，文档不开源，若不兼容，修改难度大。
3. 当前系统的依赖版本较低，无法确定框架与当前系统的兼容性。
4. 框架集成了多种连接池，会引进多余依赖，增加系统的复杂性。
5. 若后续对系统进行升级，可直接将tkmybatis替换为mybatis-plus，直接集成该框架。

---

---

#### 数据源切换的实现

首先，一个前端请求到达后端的应用后，后端的所有处理都是在一个线程中处理完毕的（开启多线程除外），所以在进行数据源切换时，使用ThreadLocal。

##### 数据源切换控制器代码：

~~~java
package com.cloud.common.multidatasource;


import org.springframework.core.NamedThreadLocal;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Objects;

/**
 * 动态数据源切换控制器
 * <p>
 * author: lzhch
 * version: v3.0.1
 * date: 2023/12/5 11:06
 */

public final class DynamicDataSourceContextHolder {

    /**
     * 为什么要用链表存储(准确的是栈)
     * <pre>
     * 为了支持嵌套切换，如ABC三个service都是不同的数据源
     * 其中A的某个业务要调B的方法，B的方法需要调用C的方法。一级一级调用切换，形成了链。
     * 传统的只设置当前线程的方式不能满足此业务需求，必须使用栈，后进先出。
     * </pre>
     */
    private static final ThreadLocal<Deque<String>> LOOKUP_KEY_HOLDER = new NamedThreadLocal<Deque<String>>("dynamic-datasource") {
        @Override
        protected Deque<String> initialValue() {
            return new ArrayDeque<>();
        }
    };

    private DynamicDataSourceContextHolder() {
    }

    /**
     * 获得当前线程数据源
     *
     * @return 数据源名称
     */
    public static String peek() {
        return LOOKUP_KEY_HOLDER.get().peek();
    }

    /**
     * 设置当前线程数据源
     * <p>
     * 如非必要不要手动调用，调用后确保最终清除
     * </p>
     *
     * @param ds 数据源名称
     */
    public static void push(String ds) {
        String dataSourceStr = Objects.isNull(ds) || ds.isEmpty() ? "" : ds;
        LOOKUP_KEY_HOLDER.get().push(dataSourceStr);
    }

    /**
     * 清空当前线程数据源
     * <p>
     * 如果当前线程是连续切换数据源 只会移除掉当前线程的数据源名称
     * </p>
     */
    public static void poll() {
        Deque<String> deque = LOOKUP_KEY_HOLDER.get();
        deque.poll();
        if (deque.isEmpty()) {
            clear();
        }
    }

    /**
     * 强制清空本地线程
     * <p>
     * 防止内存泄漏，如手动调用了push可调用此方法确保清除
     * </p>
     */
    public static void clear() {
        LOOKUP_KEY_HOLDER.remove();
    }

}
~~~

##### 读取配置文件

只有两个数据源，所以可以直接利用 Druid 的属性进行初始化，不需要额外定义属性类。当然，该方法并不是只能配置 2 个数据源，但是并不支持用该方法配置 3 个或以上的数据源，后面有更优的方案。

~~~java
package com.lzhch.practice.dynamic.config;

import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;
import jakarta.annotation.Resource;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.jdbc.datasource.DataSourceTransactionManager;

import javax.sql.DataSource;
import java.util.HashMap;
import java.util.Map;

/**
 * 阿里巴巴 Druid 数据源的固定配置
 * 适合数据源确定且不变的情况
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/15 17:53
 */

@Configuration
public class DruidDataSourceFixedConfig {

    @Value(value = "${spring.datasource.druid.slave.enable}")
    private String slaveEnabled;

    @Resource
    private DruidCommonProperties druidCommonProperties;

    /***
     *  设置主数据源
     *  initMethod = "init", 其中 init 调用 DruidDataSource 中的 init 方法;
     *  指定该属性, 可在应用启动时控制台看到初始化日志; 若不指定, 则在使用时进行初始化, 且不会打印初始化日志.
     *
     * @return DataSource
     * Author: lzhch 2023/12/6 17:36
     * Since: 1.0.0
     */
    @Bean(name = "masterDataSource", initMethod = "init")
    @ConfigurationProperties("spring.datasource.druid.master")
    public DataSource masterDataSource() {
        return druidCommonProperties.dataSource(DruidDataSourceBuilder.create().build());
    }

    /**
     * 设置从数据源
     * 当 spring.datasource.druid.slave.enable 为 true 时开启从数据源
     * {@link #slaveEnabled}
     *
     * @return DataSource
     * Author: lzhch 2023/12/6 17:38
     * Since: 1.0.0
     */
    @Bean(name = "slaveDataSource", initMethod = "init")
    @ConfigurationProperties("spring.datasource.druid.slave")
    @ConditionalOnProperty(prefix = "spring.datasource.druid.slave", name = "enable", havingValue = "true")
    public DataSource slaveDataSource() {
        return DruidDataSourceBuilder.create().build();
    }

    /***
     *  进行多数据源设置
     *
     * @return DynamicDataSource
     * Author: lzhch 2023/12/6 17:38
     * Since: 1.0.0
     */
    @Bean
    @Primary
    public DynamicDataSource dataSource() {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.MASTER, masterDataSource());
        if ("true".equals(slaveEnabled)) {
            targetDataSources.put(DataSourceType.SLAVE, slaveDataSource());
        }
        return new DynamicDataSource(masterDataSource(), targetDataSources);
    }

    /**
     * 配置事务管理器
     *
     * @return DataSourceTransactionManager
     * Author: lzhch 2023/12/26 16:04
     * Since: 1.0.0
     */
    @Primary
    @Bean(name = "masterTransactionManager")
    public DataSourceTransactionManager masterTransactionManager() {
        /*
         *  如果不进行事务管理器的配置, 在添加了 @Transactional 注解时会导致无法切换数据源;
         *  添加了该配置, 并在需要切换数据源的地方使用 @Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW) 新开启一个事务, 保证可以正常切换数据源
         *  但是该方式会导致数据不一致, 因为新开启的事务不能和原来的事务保持一致性
         */
        // PlatformTransactionManager
        return new DataSourceTransactionManager(masterDataSource());
    }

}
~~~

##### DynamicDataSource类

~~~java
package com.lzhch.practice.dynamic.config;

import com.lzhch.practice.dynamic.DynamicDataSourceContextHolder;
import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;

import javax.sql.DataSource;
import java.util.Map;

/**
 * 动态数据源
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/5 15:51
 */

public class DynamicDataSource extends AbstractRoutingDataSource {

    /***
     *  设置所有的数据源
     *
     * @param defaultTargetDataSource 默认数据源
     * @param targetDataSources 所有数据源(包含默认数据源)
     * @return: void
     * Author: lzhch 2023/12/6 16:16
     * Since: 1.0.0
     */
    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources) {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();
    }

    /***
     *  确定当前数据源
     *
     * @return Object
     * Author: lzhch 2023/12/6 16:16
     * Since: 1.0.0
     */
    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceContextHolder.peek();
    }

}
~~~

##### 定义注解

~~~java
package com.lzhch.practice.dynamic.annotation;

import java.lang.annotation.*;

/**
 * 多数据源注解
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/6 11:23
 */

@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface DataSource {

    String value() default "";

}
~~~

##### 定义切面

~~~Java
package com.lzhch.practice.dynamic.aspect;

import com.lzhch.practice.dynamic.config.DataSourceType;
import com.lzhch.practice.dynamic.DynamicDataSourceContextHolder;
import com.lzhch.practice.dynamic.annotation.DataSource;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

/**
 * 数据源切面, 进行数据源的切换
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/6 11:25
 */

@Slf4j
@Aspect
@Component
public class DataSourceAspect {

    /*
     * @annotation 匹配指定注解的方法
     * @within 匹配指定注解的类
     * 注意：这里只拦截所注解的类，如果调用的是父类的方法，那么不会拦截，除非父类方法在子类中被覆盖。
     */
    @Pointcut("@annotation(com.lzhch.practice.dynamic.annotation.DataSource) || @within(com.lzhch.practice.dynamic.annotation.DataSource)")
    public void dataSourcePointCut() {
    }

    @Around("dataSourcePointCut()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        Method method = signature.getMethod();
        Class<?> dataClass = Class.forName(signature.getDeclaringTypeName());

        DataSource dsMethod = method.getAnnotation(DataSource.class);
        DataSource dsClass = dataClass.getAnnotation(DataSource.class);
        if (dsMethod != null) {
            //方法优先，如果方法上存在注解，则优先使用方法上的注解
            DynamicDataSourceContextHolder.push(dsMethod.value());
            log.info("method first, set datasource is " + dsMethod.value());
        } else if (dsClass != null) {
            //其次类优先，如果类上存在注解，则使用类上的注解
            DynamicDataSourceContextHolder.push(dsClass.value());
            log.info("class second, set datasource is " + dsClass.value());
        } else {
            //如果都不存在，则使用默认
            DynamicDataSourceContextHolder.push(DataSourceType.MASTER);
            log.info("default, set datasource is " + DataSourceType.MASTER);
        }

        try {
            return point.proceed();
        } finally {
            // 不使用 clear 方法, 否则后面的数据源切换会被清空, 造成数据源切换失败
            // DynamicDataSourceContextHolder.clear();
            DynamicDataSourceContextHolder.poll();
            log.info("clean datasource");
        }
    }

}
~~~

##### Controller 切面

用于拦截所有的 Controller，达到在前端请求进来时根据用户的租户设置数据源。绕过使用DataSource注解的方法或类。

当前系统已经在 gateway 的过滤器中对于需要 token 校验的请求进行校验，并在请求头中增加了用户 Id，所以在切面中根据请求头中的userId即可对该请求设置数据源。但登录流程特殊，没有userId，所以后面会对登录进行单独处理。

~~~java
package com.lzhch.practice.dynamic.aspect;

import com.lzhch.practice.dynamic.DynamicDataSourceContextHolder;
import com.lzhch.practice.dynamic.annotation.DataSource;
import com.lzhch.practice.dynamic.config.DataSourceType;
import lombok.extern.slf4j.Slf4j;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.util.Objects;

/**
 * 默认数据源切面
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/8 11:11
 */

@Slf4j
@Aspect
@Component
public class DefaultDataSourceAspect {

    /***
     *  默认数据源切点
     *  默认切点: 路径为com.cloud下的任意子包中的任意类名以Controller结尾的类
     *
     * @return: void
     * Author: lzhch 2023/12/8 11:15
     * Since: 3.0.1
     */
    @Pointcut("execution(* com.lzhch.practice.business..*Controller.*(..))")
    public void defaultDataSourcePoint() {
    }

    /**
     * 根据 DataSource 注解即可切换数据源
     */
    @Around("defaultDataSourcePoint()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        String methodName = signature.getMethod().getName();
        DataSource dataSourceAnnotation = signature.getMethod().getAnnotation(DataSource.class);

        log.debug("=======Aspect Thread :{}", Thread.currentThread().getName());
        if (Objects.nonNull(dataSourceAnnotation)) {
            DynamicDataSourceContextHolder.push(dataSourceAnnotation.value());
            try {
                log.info("{} 方法, 数据源为: {}", methodName, dataSourceAnnotation.value());
                return point.proceed();
            } finally {
                // 不使用 clear 方法, 否则后面的数据源切换会被清空, 造成数据源切换失败
                DynamicDataSourceContextHolder.poll();
                log.info("clean datasource");
            }
        }

        // 根据一定规则设置对应的数据源
        DynamicDataSourceContextHolder.push(DataSourceType.MASTER);
        // log.info("操作 {} 方法, 数据源: {}", methodName, dataSource);

        try {
            // 执行方法
            // 不使用 clear 方法, 否则后面的数据源切换会被清空, 造成数据源切换失败
            return point.proceed();
        } finally {
            DynamicDataSourceContextHolder.poll();
            log.debug("clean datasource");
        }
    }

}
~~~

---

---

#### 数据源集成优化

上面是两个数据源的情况，但是业务实际采用三个数据源，如果都进行代码的配置，不利于后续的扩展，所以针对多个从库数据源进行优化。

##### 定义从库数据源属性

该方式采用Druid 的配置一致的情况下，若每个 Druid 的配置不一致，可在从库数据源属性中添加。

~~~java
package com.lzhch.practice.dynamic.config;

import lombok.Data;

/**
 * 数据源配置
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/15 17:21
 */

@Data
public class DataSourceProperties {

    /**
     * 是否启用: true 启用; false 不启用
     */
    private boolean enable;

    /**
     * 数据源名称
     */
    private String name;

    /**
     * 数据库连接URL
     */
    private String url;

    /**
     * 数据库用户名
     */
    private String username;

    /**
     * 数据库密码
     */
    private String password;

    /**
     * 驱动类名
     */
    private String driverClassName;

}
~~~

##### 定义 Druid 通用属性

在通用属性中，统一读取所有从库的数据源。

~~~java
package com.lzhch.practice.dynamic.config;

import com.alibaba.druid.pool.DruidDataSource;
import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.context.properties.NestedConfigurationProperty;
import org.springframework.context.annotation.Configuration;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * druid 配置
 * <p>
 * Author: lzhch 2023/8/17 15:27
 * Since: 3.0.1 是主库和从库读取一样的配置, 若配置不同可不使用该类
 */

@Data
@Configuration
@ConfigurationProperties(prefix = "spring.datasource.druid")
public class DruidCommonProperties {

    /**
     * 初始大小。
     */
    private int initialSize;

    /**
     * 最小空闲连接数。
     */
    private int minIdle;

    /**
     * 最大活动连接数。
     */
    private int maxActive;

    /**
     * 最大等待时间。
     */
    private int maxWait;

    /**
     * 每隔多少毫秒执行一次驱除连接空闲扫描。
     */
    private int timeBetweenEvictionRunsMillis;

    /**
     * 连接可以空闲的最短时间。
     */
    private int minEvictableIdleTimeMillis;

    /**
     * 连接可以空闲的最大时间。
     */
    private int maxEvictableIdleTimeMillis;

    /**
     * 驱逐连接时使用的验证查询。
     */
    private String validationQuery;

    /**
     * 是否在空闲连接被驱逐之前进行验证。
     */
    private boolean testWhileIdle;

    /**
     * 是否在被借出之前进行验证。
     */
    private boolean testOnBorrow;

    /**
     * 是否在返回之前进行验证。
     */
    private boolean testOnReturn;

    /**
     * 是否删除被遗弃的连接。
     */
    private boolean removeAbandoned;

    /**
     * 被遗弃连接的超时时间。
     */
    private int removeAbandonedTimeout;

    /**
     * 是否记录被遗弃的连接。
     */
    private boolean logAbandoned;

    /**
     * 连接套接字超时时间。
     */
    private int socketTimeout;

    /**
     * 从数据源属性集合, new 初始化防止不配置启动报错
     */
    @NestedConfigurationProperty
    private Map<String, DataSourceProperties> slaveDataSourcesMap = new LinkedHashMap<>();

    /**
     * 配置数据源
     *
     * @param datasource 数据源
     * @return DruidDataSource
     */
    public DruidDataSource dataSource(DruidDataSource datasource) {
        // 配置初始化大小、最小、最大
        datasource.setInitialSize(initialSize);
        datasource.setMaxActive(maxActive);
        datasource.setMinIdle(minIdle);

        // 配置获取连接等待超时的时间
        datasource.setMaxWait(maxWait);

        // 验证空闲连接使用 select 1，而不是使用MySQL的Ping. 解决连接空闲60秒报错问题(ERROR com.alibaba.druid.pool.DruidAbstractDataSource - discard long time none received connection.)
        datasource.setUsePingMethod(false);

        // 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒
        datasource.setTimeBetweenEvictionRunsMillis(timeBetweenEvictionRunsMillis);

        // 配置一个连接在池中最小、最大生存的时间，单位是毫秒
        datasource.setMinEvictableIdleTimeMillis(minEvictableIdleTimeMillis);
        datasource.setMaxEvictableIdleTimeMillis(maxEvictableIdleTimeMillis);

        //  用来检测连接是否有效的sql，要求是一个查询语句，常用select 'x'。如果validationQuery为null，testOnBorrow、testOnReturn、testWhileIdle都不会起作用。
        datasource.setValidationQuery(validationQuery);

        // 建议配置为true，不影响性能，并且保证安全性。申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，执行validationQuery检测连接是否有效。
        datasource.setTestWhileIdle(testWhileIdle);

        // 申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。
        datasource.setTestOnBorrow(testOnBorrow);

        // 归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。
        datasource.setTestOnReturn(testOnReturn);

        // 是否自动回收超时链接
        datasource.setRemoveAbandoned(removeAbandoned);

        // 超时时间
        datasource.setRemoveAbandonedTimeout(removeAbandonedTimeout);

        // 回收时记录日志, 可定位SQL和代码
        datasource.setLogAbandoned(logAbandoned);

        // socket连接超时时间(防止慢SQL查询报CJCommunicationsException: Communications link failure; java.net.SocketTimeoutException: Read timed out)
        datasource.setSocketTimeout(socketTimeout);

        return datasource;
    }

}
~~~

##### yml 文件

~~~java
server:
  port: 8080
spring:
  datasource:
    type: com.alibaba.druid.pool.DruidDataSource
    driverClassName: com.mysql.cj.jdbc.Driver
    druid:
      master:
        name: master
        url: jdbc:mysql://IP:port/test?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8&allowMultiQueries=true
        username: test
        password: Gv
        driver-class-name: com.mysql.cj.jdbc.Driver
      slaveDataSourcesMap:
        slave1:
          enable: true
          name: slave
          url: jdbc:mysql://localhost:3306/order?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8&allowMultiQueries=true
          username: root
          password: root
          driver-class-name: com.mysql.cj.jdbc.Driver
        slave2:
          enable: true
          name: slave
          url: jdbc:mysql://localhost:3306/order?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8&allowMultiQueries=true
          username: root
          password: root
          driver-class-name: com.mysql.cj.jdbc.Driver
        slave3:
          enable: true
          name: slave
          url: jdbc:mysql://localhost:3306/order?useUnicode=true&characterEncoding=utf8&zeroDateTimeBehavior=convertToNull&useSSL=true&serverTimezone=GMT%2B8&allowMultiQueries=true
          username: root
          password: root
          driver-class-name: com.mysql.cj.jdbc.Driver
      initialSize: 5
      minIdle: 10
      maxActive: 20
      maxWait: 60000
      timeBetweenEvictionRunsMillis: 60000
      minEvictableIdleTimeMillis: 300000
      maxEvictableIdleTimeMillis: 900000
      validationQuery: SELECT 1 FROM DUAL
      testWhileIdle: true
      testOnBorrow: false
      testOnReturn: false
      webStatFilter:
        enabled: true
      statViewServlet:
        enabled: true
        allow:
        url-pattern: /monitor/druid/*
      filter:
        stat:
          enabled: true
          log-slow-sql: true
          slow-sql-millis: 1000
          merge-sql: true
        wall:
          config:
            multi-statement-allow: true
      remove-abandoned: true
      # 单位:秒
      remove-abandoned-timeout: 900
      log-abandoned: true
      # socket超时时间,防止慢SQL报错,单位:毫秒
      socket-timeout: 30000
~~~

##### 多数据源初始化

遍历从配置文件中获取的所有的从库数据源配置，统一进行加载。便于后续扩展其他数据源，只需对租户和数据源进行配置即可，无需对代码进行改动。

~~~java
package com.lzhch.practice.dynamic.config;

import com.alibaba.druid.pool.DruidDataSource;
import com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceBuilder;
import com.alibaba.druid.support.jakarta.StatViewServlet;
import com.alibaba.druid.support.jakarta.WebStatFilter;
import com.alibaba.druid.support.spring.stat.DruidStatInterceptor;
import jakarta.annotation.Resource;
import org.springframework.aop.support.DefaultPointcutAdvisor;
import org.springframework.aop.support.JdkRegexpMethodPointcut;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.boot.web.servlet.ServletRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Primary;
import org.springframework.context.annotation.Scope;

import javax.sql.DataSource;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Map;

/**
 * 阿里巴巴 Druid 数据源动态的配置
 * 适合数据源不确定或者经常变动的情况
 * <p>
 * author: lzhch
 * version: v1.0
 * date: 2023/12/5 15:03
 */

@Configuration
public class DruidDataSourceDynamicConfig {

    @Resource
    private DruidCommonProperties druidCommonProperties;

    /***
     *  设置主数据源
     *  initMethod = "init", 其中 init 调用 DruidDataSource 中的 init 方法;
     *  指定该属性, 可在应用启动时控制台看到初始化日志; 若不指定, 则在使用时进行初始化, 且不会打印初始化日志.
     *
     * @return DataSource
     * Author: lzhch 2023/12/6 17:36
     * Since: 1.0.0
     */
    @Bean(name = "masterDataSource", initMethod = "init")
    @ConfigurationProperties("spring.datasource.druid.master")
    public DataSource masterDataSource() {
        return druidCommonProperties.dataSource(DruidDataSourceBuilder.create().build());
    }

    /**
     * 进行多数据源设置
     *
     * @return DynamicDataSource
     * Author: lzhch 2023/12/6 17:38
     * Since: 1.0.0
     */
    @Bean
    @Primary
    public DynamicDataSource dataSource() throws SQLException {
        Map<Object, Object> targetDataSources = new HashMap<>();
        targetDataSources.put(DataSourceType.MASTER, masterDataSource());

        // 获取Druid配置的从数据库映射Map
        Map<String, DataSourceProperties> allDataSourcesMap = druidCommonProperties.getSlaveDataSourcesMap();

        // 遍历从数据库映射Map
        for (Map.Entry<String, DataSourceProperties> entry : allDataSourcesMap.entrySet()) {
            // 获取键值
            String key = entry.getKey();
            DataSourceProperties value = entry.getValue();
            // 创建Druid数据源对象
            DruidDataSource druidDataSource = DruidDataSourceBuilder.create().build();
            // 设置数据源名称
            druidDataSource.setName(key);
            // 设置数据库连接URL
            druidDataSource.setUrl(value.getUrl());
            // 设置用户名
            druidDataSource.setUsername(value.getUsername());
            // 设置密码
            druidDataSource.setPassword(value.getPassword());
            // 设置驱动类名
            druidDataSource.setDriverClassName(value.getDriverClassName());
            // 将数据源添加到DruidCommonProperties中
            druidCommonProperties.dataSource(druidDataSource);
            // 初始化数据源
            druidDataSource.init();
            // 将数据源添加到targetDataSources中
            targetDataSources.put(key, druidDataSource);
        }

        // 返回动态数据源
        return new DynamicDataSource(masterDataSource(), targetDataSources);
    }

}
~~~

##### DynamicDataSource类

和上面的一致。

~~~java
public class DynamicDataSource extends AbstractRoutingDataSource {

    public DynamicDataSource(DataSource defaultTargetDataSource, Map<Object, Object> targetDataSources) {
        super.setDefaultTargetDataSource(defaultTargetDataSource);
        super.setTargetDataSources(targetDataSources);
        super.afterPropertiesSet();
    }

    @Override
    protected Object determineCurrentLookupKey() {
        return DynamicDataSourceContextHolder.peek();
    }

}
~~~

---

---

#### 登录整合多数据源

##### 说明

在用户登录时，需要根据用户设置的默认租户，进行默认数据源的设置，并查询该用户的所有租户在页面进行展示。多租户的用户可以在页面进行租户的切换。

由于系统的历史原因，系统存在两个登录接口，且登录接口的逻辑并不是纯粹的校验用户名密码等，而是耦合了菜单和角色等查询，所以需要针对一些特定的接口进行放行，否则会被 Controller 切面拦截无法访问（因为没有登录之前，拿不到用户的默认租户）。

##### 实现

重写获取用户信息的方法，先去主库查询用户的租户信息（主库只维护关系，不存储用户信息），根据租户信息切换相应的数据源查询用户信息。

将用户的当前租户数据源放到 Redis 中，便于后续读取以及切换数据源。

针对特殊接口，添加 DataSource 注解进行放行。

##### 参数解析器HandlerMethodArgumentResolver

在登录（成功登录并展示相应的页面）流程中，涉及到使用了自定义参数解析器LoginUserHandlerResolver的接口。

在 Controller 方法的参数前加上 LoginUser 注解，LoginUser 为自定义注解。

~~~java
package com.cloud.system.resolver;

import com.cloud.common.annotation.LoginUser;
import com.cloud.system.domain.entity.SysUser;
import lombok.extern.slf4j.Slf4j;
import org.jetbrains.annotations.NotNull;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.MethodParameter;
import org.springframework.web.bind.support.WebDataBinderFactory;
import org.springframework.web.context.request.NativeWebRequest;
import org.springframework.web.method.support.HandlerMethodArgumentResolver;
import org.springframework.web.method.support.ModelAndViewContainer;

@Slf4j
@Configuration
public class LoginUserHandlerResolver implements HandlerMethodArgumentResolver {

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        // 参数类型是 SysUser 且前面有 LoginUser 注解
        return parameter.getParameterType().isAssignableFrom(SysUser.class)
                && parameter.hasParameterAnnotation(LoginUser.class);
    }

    @Override
    public Object resolveArgument(@NotNull MethodParameter parameter, ModelAndViewContainer container,
                                  @NotNull NativeWebRequest nativeWebRequest, WebDataBinderFactory factory) {
        // 进行处理
        return null;
    }
}
~~~

如果上面的supportsParameter方法返回 true，那么就执行resolveArgument方法。在resolveArgument方法中，可以对参数进行一些赋值，比如接口传参只有 Id，那么在resolveArgument方法中就可以进行根据 ID 查询用户信息。这样就达到了接口传参是全部的用户信息，可以直接在 Controller 方法中进行使用和处理。

---

---

#### 定时任务数据源切换处理

##### 说明

需要将原本的定时任务分别执行两遍，放入不同的租户数据源中，所以采用切面统一处理。

##### 实现

将定时任务的 Controller 建立统一的包路径，由切面去进行拦截并执行目标方法。

在切面中，查询全部租户数据源，并轮训数据源调用目标方法，便于后续扩展新的租户数据源。在每一个租户数据源调用时进行异常捕获，发生异常则发送 IHaier 消息进行提醒。

因为部分定时任务执行频率较高，且数据源的变更频率极低，所以在切面中对数据源进行本地缓存，只在第一次调用定时任务时查询数据库，减少 RPC 调用，减少网络资源开销。

~~~java
/**
 * xxl-job 数据源切面, 进行数据源的切换
 * <p>
 * author: lzhch
 * version: v3.0.1
 * date: 2023/12/27 11:15
 */

@Slf4j
@Aspect
@Component
public class XxlJobDataSourceAspect {

    // 租户数据源进行本地缓存, 减少 RPC 频率
    private static final Map<String, String> TENANT_DATASOURCE = new ConcurrentHashMap<>(3);

    @Pointcut("execution(* com.cloud.*.task.controller.*Controller.*(..))")
    public void defaultDataSourcePoint() {
    }

    @Around("defaultDataSourcePoint()")
    public Object around(ProceedingJoinPoint point) throws Throwable {
        MethodSignature signature = (MethodSignature) point.getSignature();
        String methodName = signature.getMethod().getName();

        RemoteIhaierService remoteIhaierService = ApplicationContextUtil.getBean(RemoteIhaierService.class);
        if (CollUtil.isEmpty(TENANT_DATASOURCE)) {
            initDatasourceMap();
        }

        Object res = null;
        for (Map.Entry<String, String> entry : TENANT_DATASOURCE.entrySet()) {
            try {
                log.info("{} 方法, 数据源为: {}", methodName, entry.getValue());
                DynamicDataSourceContextHolder.push(entry.getValue());
                res = point.proceed();
                DynamicDataSourceContextHolder.poll();
            } catch (Throwable e) {
                log.error(e.getMessage(), e);

                // 发送 IHaier 消息
                IHaierSendRobotMsgReq sendRobotMsgReq = new IHaierSendRobotMsgReq();
                JSONObject content = new JSONObject();
                content.put(IhaierConstants.MSG_TYPE_TEXT, String.format("定时任务执行失败! 方法: %s; 数据源: %s; 异常原因: %s", methodName, entry.getValue(), e.getMessage()));
                sendRobotMsgReq.setMsgType(IhaierConstants.MSG_TYPE_TEXT);
                sendRobotMsgReq.setContent(content);
                remoteIhaierService.sendRobotMessage(sendRobotMsgReq);
            } finally {
                DynamicDataSourceContextHolder.poll();
                log.info("clean datasource");
            }
        }
        return res;
    }

    /**
     * 初始化数据源 Map
     *
     * @return: void
     * Author: lzhch 2023/12/28 10:18
     * Since: 3.0.1
     */
    private static void initDatasourceMap() {
        RemoteTenantDataSourceService remoteTenantDataSourceService = ApplicationContextUtil.getBean(RemoteTenantDataSourceService.class);
        List<SysTenantDatasourceRes> datasourceList = remoteTenantDataSourceService.selectAll();
        Assert.notEmpty(datasourceList, "数据源列表为空");

        datasourceList = datasourceList.stream()
                .filter(item -> !DataSourceType.MASTER.equals(item.getDataSource()))
                .collect(Collectors.toList());
        Assert.notEmpty(datasourceList, "没有配置租户数据源");

        for (SysTenantDatasourceRes item : datasourceList) {
            TENANT_DATASOURCE.put(item.getTenantId(), item.getDataSource());
        }
    }

}
~~~

---

---

#### 多数据源事务问题（待完善）

多数据源会存在事务问题，因为原本是通过一个连接来确保事务生效的，但是现在一个应用会在一次请求中切换不同的数据源，也就是说应用和 MySQL 不能保持在同一个连接中，所以会产生事务不生效问题。

尝试了很多方案都失败。

1. 直接添加 @Transactional 注解，无法切换数据源。

2. 外层添加 @Transactional 注解，内层方法添加 @Transactional 注解，并指定事务传播方式为 Propagation.REQUIRES_NEW，可以切换数据源，但是这本质就相当于两个事务，所以存在数据一致性问题。

3. 尝试注册多个事务管理器，同样不生效。

4. 尝试使用 seata，不生效。seata 着重解决的是不同应用间的分布式事务问题，但是对于同一应用内部的多数据源问题没有支持。

5. 集成dynamic-datasource-spring-boot-starter后，单独使用@DSTransactional，相关配置的读取使用自定义的，事务不生效；<u>未尝试单独使用dynamic-datasource-spring-boot-starter</u>。

6. 其他的需要配置两套 mapper 的方案不考虑，不符合项目需求；项目需求是针对一套 mapper 可以走不同的数据源，而不是一套 mapper 只能走一个数据源，然后进行多个配置，同一个 mapper 复制两套，增加了维护成本。所以，大的前提是根据一套 mapper 实现多数据源的事务。

8. 实现 XA 模式，二阶段提交，存在事务时间长导致的性能问题，原生 mybatis（注解+XML）均可实现事务，mybatis-plus 框架（含自带 mapper 方法）也均可实现事务；但tkmybatis框架的自带方法无法实现事务，报错（推测是绑定关系的问题）：

   ~~~java
   2024-01-09 10:28:58.243 ERROR 4843 --- [  XNIO-1 task-1] c.c.c.exception.GlobalExceptionHandler   : 运行时异常:
   
   org.mybatis.spring.MyBatisSystemException: nested exception is org.apache.ibatis.builder.BuilderException: Error invoking SqlProvider method (tk.mybatis.mapper.provider.base.BaseUpdateProvider.dynamicSQL).  Cause: java.lang.InstantiationException: tk.mybatis.mapper.provider.base.BaseUpdateProvider
   	at org.mybatis.spring.MyBatisExceptionTranslator.translateExceptionIfPossible(MyBatisExceptionTranslator.java:77)
   	at com.cloud.common.multidatasource.transaction.jta.CustomSqlSessionTemplate$SqlSessionInterceptor.invoke(CustomSqlSessionTemplate.java:288)
   	at com.sun.proxy.$Proxy173.update(Unknown Source)
   	at com.cloud.common.multidatasource.transaction.jta.CustomSqlSessionTemplate.update(CustomSqlSessionTemplate.java:186)
   	at org.apache.ibatis.binding.MapperMethod.execute(MapperMethod.java:63)
   	at org.apache.ibatis.binding.MapperProxy.invoke(MapperProxy.java:59)
   	at com.sun.proxy.$Proxy395.updateByPrimaryKeySelective(Unknown Source)
   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   	at java.lang.reflect.Method.invoke(Method.java:498)
   	at org.springframework.aop.support.AopUtils.invokeJoinpointUsingReflection(AopUtils.java:344)
   	at org.springframework.aop.framework.JdkDynamicAopProxy.invoke(JdkDynamicAopProxy.java:205)
   	at com.sun.proxy.$Proxy396.updateByPrimaryKeySelective(Unknown Source)
   	at com.cloud.order.service.impl.OmsTestServiceImpl.selfUpdateById(OmsTestServiceImpl.java:66)
   	at com.cloud.order.service.impl.OmsTestServiceImpl$$FastClassBySpringCGLIB$$7bbcad5d.invoke(<generated>)
   	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)
   	at com.cloud.common.multidatasource.aspect.DataSourceAspect.around(DataSourceAspect.java:65)
   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   	at java.lang.reflect.Method.invoke(Method.java:498)
   	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
   	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
   	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:175)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at com.alibaba.druid.support.spring.stat.DruidStatInterceptor.invoke(DruidStatInterceptor.java:70)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at io.seata.spring.annotation.GlobalTransactionalInterceptor.invoke(GlobalTransactionalInterceptor.java:156)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
   	at com.cloud.order.service.impl.OmsTestServiceImpl$$EnhancerBySpringCGLIB$$c35431c7.selfUpdateById(<generated>)
   	at com.cloud.order.controller.OmsTestController.multiDatasourceTransactional(OmsTestController.java:137)
   	at com.cloud.order.controller.OmsTestController$$FastClassBySpringCGLIB$$f2bca057.invoke(<generated>)
   	at org.springframework.cglib.proxy.MethodProxy.invoke(MethodProxy.java:218)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.invokeJoinpoint(CglibAopProxy.java:769)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:163)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.aop.aspectj.MethodInvocationProceedingJoinPoint.proceed(MethodInvocationProceedingJoinPoint.java:88)
   	at com.cloud.common.multidatasource.aspect.DefaultDataSourceAspect.around(DefaultDataSourceAspect.java:98)
   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   	at java.lang.reflect.Method.invoke(Method.java:498)
   	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethodWithGivenArgs(AbstractAspectJAdvice.java:644)
   	at org.springframework.aop.aspectj.AbstractAspectJAdvice.invokeAdviceMethod(AbstractAspectJAdvice.java:633)
   	at org.springframework.aop.aspectj.AspectJAroundAdvice.invoke(AspectJAroundAdvice.java:70)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.transaction.interceptor.TransactionAspectSupport.invokeWithinTransaction(TransactionAspectSupport.java:366)
   	at org.springframework.transaction.interceptor.TransactionInterceptor.invoke(TransactionInterceptor.java:99)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at com.alibaba.druid.support.spring.stat.DruidStatInterceptor.invoke(DruidStatInterceptor.java:70)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.aop.interceptor.ExposeInvocationInterceptor.invoke(ExposeInvocationInterceptor.java:95)
   	at org.springframework.aop.framework.ReflectiveMethodInvocation.proceed(ReflectiveMethodInvocation.java:186)
   	at org.springframework.aop.framework.CglibAopProxy$CglibMethodInvocation.proceed(CglibAopProxy.java:747)
   	at org.springframework.aop.framework.CglibAopProxy$DynamicAdvisedInterceptor.intercept(CglibAopProxy.java:689)
   	at com.cloud.order.controller.OmsTestController$$EnhancerBySpringCGLIB$$aeafabe4.multiDatasourceTransactional(<generated>)
   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   	at java.lang.reflect.Method.invoke(Method.java:498)
   	at org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:190)
   	at org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:138)
   	at org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:106)
   	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandlerMethod(RequestMappingHandlerAdapter.java:879)
   	at org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:793)
   	at org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:87)
   	at org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:1040)
   	at org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:943)
   	at org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:1006)
   	at org.springframework.web.servlet.FrameworkServlet.doPost(FrameworkServlet.java:909)
   	at javax.servlet.http.HttpServlet.service(HttpServlet.java:523)
   	at org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:883)
   	at javax.servlet.http.HttpServlet.service(HttpServlet.java:590)
   	at io.undertow.servlet.handlers.ServletHandler.handleRequest(ServletHandler.java:74)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:129)
   	at com.github.xiaoymin.swaggerbootstrapui.filter.SecurityBasicAuthFilter.doFilter(SecurityBasicAuthFilter.java:84)
   	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
   	at com.github.xiaoymin.swaggerbootstrapui.filter.ProductionSecurityFilter.doFilter(ProductionSecurityFilter.java:53)
   	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
   	at com.alibaba.druid.support.http.WebStatFilter.doFilter(WebStatFilter.java:114)
   	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
   	at org.springframework.web.filter.RequestContextFilter.doFilterInternal(RequestContextFilter.java:100)
   	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
   	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
   	at org.springframework.web.filter.FormContentFilter.doFilterInternal(FormContentFilter.java:93)
   	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
   	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
   	at org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:201)
   	at org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:119)
   	at io.undertow.servlet.core.ManagedFilter.doFilter(ManagedFilter.java:61)
   	at io.undertow.servlet.handlers.FilterHandler$FilterChainImpl.doFilter(FilterHandler.java:131)
   	at io.undertow.servlet.handlers.FilterHandler.handleRequest(FilterHandler.java:84)
   	at io.undertow.servlet.handlers.security.ServletSecurityRoleHandler.handleRequest(ServletSecurityRoleHandler.java:62)
   	at io.undertow.servlet.handlers.ServletChain$1.handleRequest(ServletChain.java:68)
   	at io.undertow.servlet.handlers.ServletDispatchingHandler.handleRequest(ServletDispatchingHandler.java:36)
   	at io.undertow.servlet.handlers.RedirectDirHandler.handleRequest(RedirectDirHandler.java:68)
   	at io.undertow.servlet.handlers.security.SSLInformationAssociationHandler.handleRequest(SSLInformationAssociationHandler.java:132)
   	at io.undertow.servlet.handlers.security.ServletAuthenticationCallHandler.handleRequest(ServletAuthenticationCallHandler.java:57)
   	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
   	at io.undertow.security.handlers.AbstractConfidentialityHandler.handleRequest(AbstractConfidentialityHandler.java:46)
   	at io.undertow.servlet.handlers.security.ServletConfidentialityConstraintHandler.handleRequest(ServletConfidentialityConstraintHandler.java:64)
   	at io.undertow.security.handlers.AuthenticationMechanismsHandler.handleRequest(AuthenticationMechanismsHandler.java:60)
   	at io.undertow.servlet.handlers.security.CachedAuthenticatedSessionHandler.handleRequest(CachedAuthenticatedSessionHandler.java:77)
   	at io.undertow.security.handlers.AbstractSecurityContextAssociationHandler.handleRequest(AbstractSecurityContextAssociationHandler.java:43)
   	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
   	at io.undertow.server.handlers.PredicateHandler.handleRequest(PredicateHandler.java:43)
   	at io.undertow.servlet.handlers.SessionRestoringHandler.handleRequest(SessionRestoringHandler.java:119)
   	at io.undertow.servlet.handlers.ServletInitialHandler.handleFirstRequest(ServletInitialHandler.java:269)
   	at io.undertow.servlet.handlers.ServletInitialHandler.access$100(ServletInitialHandler.java:78)
   	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:133)
   	at io.undertow.servlet.handlers.ServletInitialHandler$2.call(ServletInitialHandler.java:130)
   	at io.undertow.servlet.core.ServletRequestContextThreadSetupAction$1.call(ServletRequestContextThreadSetupAction.java:48)
   	at io.undertow.servlet.core.ContextClassLoaderSetupAction$1.call(ContextClassLoaderSetupAction.java:43)
   	at io.undertow.servlet.handlers.ServletInitialHandler.dispatchRequest(ServletInitialHandler.java:249)
   	at io.undertow.servlet.handlers.ServletInitialHandler.access$000(ServletInitialHandler.java:78)
   	at io.undertow.servlet.handlers.ServletInitialHandler$1.handleRequest(ServletInitialHandler.java:99)
   	at io.undertow.server.Connectors.executeRootHandler(Connectors.java:376)
   	at io.undertow.server.HttpServerExchange$1.run(HttpServerExchange.java:830)
   	at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149)
   	at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624)
   	at java.lang.Thread.run(Thread.java:748)
   Caused by: org.apache.ibatis.builder.BuilderException: Error invoking SqlProvider method (tk.mybatis.mapper.provider.base.BaseUpdateProvider.dynamicSQL).  Cause: java.lang.InstantiationException: tk.mybatis.mapper.provider.base.BaseUpdateProvider
   	at org.apache.ibatis.builder.annotation.ProviderSqlSource.createSqlSource(ProviderSqlSource.java:134)
   	at org.apache.ibatis.builder.annotation.ProviderSqlSource.getBoundSql(ProviderSqlSource.java:102)
   	at org.apache.ibatis.mapping.MappedStatement.getBoundSql(MappedStatement.java:292)
   	at org.apache.ibatis.executor.statement.BaseStatementHandler.<init>(BaseStatementHandler.java:64)
   	at org.apache.ibatis.executor.statement.PreparedStatementHandler.<init>(PreparedStatementHandler.java:40)
   	at org.apache.ibatis.executor.statement.RoutingStatementHandler.<init>(RoutingStatementHandler.java:46)
   	at org.apache.ibatis.session.Configuration.newStatementHandler(Configuration.java:558)
   	at org.apache.ibatis.executor.SimpleExecutor.doUpdate(SimpleExecutor.java:48)
   	at org.apache.ibatis.executor.BaseExecutor.update(BaseExecutor.java:117)
   	at org.apache.ibatis.executor.CachingExecutor.update(CachingExecutor.java:76)
   	at org.apache.ibatis.session.defaults.DefaultSqlSession.update(DefaultSqlSession.java:198)
   	at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
   	at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
   	at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
   	at java.lang.reflect.Method.invoke(Method.java:498)
   	at com.cloud.common.multidatasource.transaction.jta.CustomSqlSessionTemplate$SqlSessionInterceptor.invoke(CustomSqlSessionTemplate.java:277)
   	... 139 common frames omitted
   Caused by: java.lang.InstantiationException: tk.mybatis.mapper.provider.base.BaseUpdateProvider
   	at java.lang.Class.newInstance(Class.java:427)
   	at org.apache.ibatis.builder.annotation.ProviderSqlSource.invokeProviderMethod(ProviderSqlSource.java:165)
   	at org.apache.ibatis.builder.annotation.ProviderSqlSource.createSqlSource(ProviderSqlSource.java:116)
   	... 154 common frames omitted
   Caused by: java.lang.NoSuchMethodException: tk.mybatis.mapper.provider.base.BaseUpdateProvider.<init>()
   	at java.lang.Class.getConstructor0(Class.java:3082)
   	at java.lang.Class.newInstance(Class.java:412)
   	... 156 common frames omitted
   ~~~
   
9. 自定义事务管理器，替换到 spring 默认的事务管理器，成功！

