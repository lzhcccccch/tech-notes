# 为什么不推荐使用@Autowired

[toc]

## 简介

在 IntelliJ IDEA 中，通常不推荐使用 @Autowired 进行依赖注入，而是推荐使用构造器注入。这是因为构造器注入在可维护性、可测试性和可读性方面更具优势。以下是详细的原因和解释：

---

## 可维护性和强制依赖性

### 构造器注入的优势

- 构造器注入通过构造函数的参数明确地表达了类的依赖性，开发者一眼就能看出该类依赖了哪些组件。

- 当依赖的组件发生变更（如新增或删除依赖）时，IDE（如 IntelliJ IDEA）会立刻提示构造器的参数不匹配，从而强制开发者关注到依赖的变更。

- 遵循最小化构造函数的依赖原则，当依赖太多时，开发者会被迫考虑重构类的设计。

### @Autowired 的劣势：

- @Autowired 不会在编译时检查依赖关系，直到运行时才会发现依赖关系缺失（如忘记定义 Bean 或者自动装配失败），这容易导致运行时异常。

- 如果不小心删除了某个依赖，IDE 不会提示任何错误，编译也不会报错。

---

## 可读性和清晰性

### 构造器注入的优势

- 通过构造器，清晰地表明了依赖关系，使代码的依赖结构一目了然，符合“自文档化代码”的原则。

- 任何读到这个类的开发者都能直接在构造函数上看到类的依赖，无需向上翻找代码中的 @Autowired 字段。

### @Autowired 的劣势

- 当一个类中有多个 @Autowired 字段时，不容易发现依赖的数量和位置，特别是类的逻辑复杂时，开发者必须滚动屏幕找到所有 @Autowired 字段。

- @Autowired 字段会被悄悄注入，开发者可能误以为这个类不依赖其他类，从而导致误判。

---

## 可测试性（单元测试）

### 构造器注入的优势

- 在编写单元测试时，可以通过构造函数轻松传入模拟对象（mock 对象），不需要依赖 Spring 容器来提供依赖。

- 构造器注入使得类的可测试性更强，因为它的依赖不依赖于 Spring 容器，可以在不加载 Spring Context 的情况下对其进行单元测试。

### @Autowired 的劣势：

- 如果使用 @Autowired，那么要为类注入依赖，通常需要加载整个 Spring 容器（通过 @SpringBootTest 注解等），这会导致测试运行时间变长。

- 使用 @Autowired 需要依赖 Spring 的上下文，而不使用 @Autowired 的构造器注入则可以完全独立于 Spring 上下文，更加简洁高效。

---

## 避免不必要的反射和代理

### 构造器注入的优势

- 构造器注入只在实例化对象时注入依赖，不依赖 Spring 的代理机制，性能上稍微更优。

- 现代 IDE（如 IntelliJ IDEA）和Lombok 的 @RequiredArgsConstructor 可以自动生成构造函数，减少了模板代码。

### @Autowired 的劣势

- @Autowired 注入依赖于Spring 的反射和代理机制，会在运行时动态注入字段，无法通过简单的 Java 语言机制检查类型错误，而且可能在 JVM 启动期间额外消耗时间。

- 反射和代理通常会稍微降低程序的性能，但这在大多数情况下影响不大。

---

## 可控的依赖管理（循环依赖的处理）

### 构造器注入的优势

- 用构造器注入时，如果有循环依赖（A 依赖 B，B 依赖 A），Spring 在编译时或构建时就会提示错误，这会让开发者立刻发现设计上的问题。

- 循环依赖本质上是设计不良的代码，构造器注入会迫使开发者重新设计类的依赖，从而使设计更加清晰。

### @Autowired 的劣势

- 使用 @Autowired 可能会掩盖循环依赖问题，因为 Spring 可能会使用代理模式解决这个问题，这使得代码看似没有问题，但运行时可能会产生一些意想不到的行为。

- 这种“偷偷摸摸”解决循环依赖的方式，违背了代码清晰性原则，让开发者难以察觉问题。

---

## 对 IDE 支持的提示和重构

### 构造器注入的优势

- 当你在构造函数中删除或新增依赖时，IntelliJ IDEA 会立刻提示编译错误，并在重构时更新依赖。

- 使用 IntelliJ IDEA 进行代码重构（如重命名依赖字段）时，构造器参数也会一并被重命名。

### @Autowired 的劣势

- 如果你直接删除了 @Autowired 字段，IDE 不会给出任何编译错误提示，只能在运行时才能捕获异常。

- 在重构时，IDE 不会提示你可能遗漏的依赖关系，从而导致潜在的 bug。

---

## 与 Lombok 结合的便利性

- 使用 Lombok 中的 @RequiredArgsConstructor 注解，自动生成构造函数，避免了编写构造函数的麻烦。

- 不需要手动书写“模板化的构造器代码”，只需一行注解即可完成。

**示例**：

~~~java
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;

@Service
@RequiredArgsConstructor
public class MyService {
    private final UserService userService;
    private final ProductService productService;
}
~~~

在这种方式下，Spring 自动将 userService 和 productService 作为构造器的依赖注入，无须手动写构造函数，简洁优雅。

---

## 总结对比

| **对比项**       | **构造器注入**                       | **@Autowired 注入**           |
| ---------------- | ------------------------------------ | ----------------------------- |
| **依赖的可见性** | 一目了然，构造函数中明确定义         | 隐式，依赖分散在字段中        |
| **错误提示**     | 编译时提示，及时发现依赖问题         | 运行时报错，难以及时发现问题  |
| **可测试性**     | 方便传入 mock 对象，无需 Spring 容器 | 需要依赖 Spring 容器          |
| **依赖变化提示** | 变化立刻触发编译错误                 | 无提示，可能在运行时报错      |
| **避免循环依赖** | 立刻编译报错，需重构设计             | Spring 代理“悄悄”解决循环依赖 |
| **与 IDE 整合**  | 更好的提示和重构支持                 | 无明显提示，难以追踪          |

---

## 总结建议

1. 始终优先使用“构造器注入”，特别是对于必须依赖的组件。

2. 对于可选依赖（如 Bean 可选注入），可考虑使用 @Autowired 结合 @Qualifier。

3. 使用 Lombok 的 @RequiredArgsConstructor 简化构造器注入的模板化代码。

通过采用构造器注入，不仅能提高代码的可读性和可测试性，还能避免运行时的意外错误，让代码更加健壮。